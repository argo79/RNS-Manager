<!DOCTYPE html>
<html>
<head>
    <title>RNS MeshChat - LXMF Client Completo</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="{{ url_for('static', filename='rns_lxmf.css') }}">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        .aspect-menu-container {
            margin: 8px 0;
            width: 100%;
        }
        .aspect-selector {
            width: 100%;
            padding: 6px 8px;
            background: #5a2e00;
            color: #ffaa00;
            border: 1px solid #ffaa00;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23ffaa00' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6 9 12 15 18 9'/></svg>");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 12px;
            padding-right: 28px;
        }
        
    </style>
</head>
<body>
    <!-- MODALE PER ANTEPRIME -->
    <div id="mediaModal" class="lxmf-modal" onclick="closeModal()">
        <span class="lxmf-modal-close" onclick="closeModal()">&times;</span>
        <img id="modalImage" class="lxmf-modal-content" style="display: none;">
        <video id="modalVideo" class="lxmf-modal-content" controls style="display: none;"></video>
    </div>

    <!-- DEBUG PANEL -->
    <div id="debugPanel" class="debug-panel">
        <div style="display: flex; justify-content: space-between; border-bottom: 1px solid #ff00ff; padding-bottom: 4px; margin-bottom: 4px;">
            <span style="color: #ff00ff; font-weight: bold;">üîç DEBUG DATABASE</span>
            <button onclick="document.getElementById('debugPanel').style.display='none'" style="background: #ff00ff; color: black; border: none; cursor: pointer; padding: 2px 8px;">‚úï</button>
        </div>
        <div id="debugContent" style="margin-top: 4px;"></div>
    </div>
    <button class="debug-button" onclick="document.getElementById('debugPanel').style.display='block'">üêõ DEBUG</button>

    <div class="lxmf-chat">
        <!-- HEADER - STATO IDENTIT√Ä -->
        <div class="lxmf-header">
            <div class="header-left">
                <h1>üì® LXMF CHAT</h1>
            </div>
            <div class="identity-info">
                <div class="identity-badge" id="identityDisplay">
                    <span id="identityStatus">‚ö™</span>
                    <span id="identityName">Nessuna identit√†</span>
                </div>
                <div id="identityHash" class="identity-hash"></div>
                <div id="connectionStatus" class="status offline"></div>
                <div class="stats-badge" id="identityStats"></div>
                <a href="/" class="back-button">‚Üê TORNA</a>
            </div>
        </div>

        <!-- PANNELLO SELEZIONE IDENTIT√Ä -->
        <div id="initPanel" class="lxmf-init-panel">
            <h2>üîê SELEZIONA IDENTIT√Ä</h2>
            <div class="lxmf-identity-selector">
                <label>Identit√† in ~/.rns_manager/storage/</label>
                <select id="identitySelect">
                    <option value="">Caricamento...</option>
                </select>
            </div>
            <button id="initButton" class="lxmf-init-button" onclick="selectIdentity()">AVVIA CHAT</button>
            <div id="initStatus" class="lxmf-init-status">Pronto</div>
        </div>

        <!-- CHAT PRINCIPALE -->
        <div id="chatContainer" class="lxmf-container" style="display: none;">
            
            <!-- COLONNA 1 - PEER LIST (FISSA 300px) -->
            <div class="lxmf-peer-column">
                <div class="lxmf-peer-header">
                    <h3>üîç PEER LXMF</h3>
                    <span class="lxmf-peer-count" id="peerCount">0</span>
                </div>
                
                <!-- Info identit√† corrente -->
                <div class="identity-box">
                    <div class="identity-name-large" id="sidebarIdentityName">-</div>
                    <div class="aspect-badge-sidebar" id="sidebarAspect">lxmf.delivery</div>
                    <div class="delivery-hash-box" id="sidebarDeliveryHash"></div>
                    <div class="identity-hash-small" id="sidebarIdentityHash"></div>
                </div>
                
                <!-- Controlli ordinamento -->
                <div class="lxmf-sort-controls">
                    <button id="sortTimeBtn" class="lxmf-sort-btn active" onclick="setSortMode('time')">
                        <span class="lxmf-sort-icon" id="timeIcon">‚¨áÔ∏è</span> Ricezione
                    </button>
                    <button id="sortHopsBtn" class="lxmf-sort-btn" onclick="setSortMode('hops')">
                        <span class="lxmf-sort-icon" id="hopsIcon">‚¨ÜÔ∏è</span> Distanza
                    </button>
                    <button id="sortSignalBtn" class="lxmf-sort-btn" onclick="setSortMode('signal')">
                        <span class="lxmf-sort-icon" id="signalIcon">‚¨áÔ∏è</span> Segnale
                    </button>
                </div>
                
                <!-- Ricerca -->
                <div class="lxmf-peer-search">
                    <div class="search-container">
                        <input type="text" id="peerSearch" placeholder="Filtra per nome o hash...">
                        <span class="search-clear" onclick="clearSearch()">‚úï</span>
                    </div>
                </div>
                
                <!-- Lista peer -->
                <div class="lxmf-peer-list" id="peerList">
                    <div class="lxmf-loading">Caricamento peer...</div>
                </div>
                
                <!-- Statistiche peer -->
                <div class="lxmf-shortcut-hint">
                    <span id="peerCountDisplay">0</span> peer | 
                    <span id="onlineCount">0</span> online |
                    <span id="avgHops">0</span> hop avg
                </div>
            </div>

            <!-- COLONNA 2 - MESSAGGI (VARIABILE) -->
            <div class="lxmf-message-column">
                <div class="lxmf-message-header">
                    <h3>üí¨ MESSAGGI</h3>
                    <div class="lxmf-selected-peer" id="selectedPeerDisplay">Nessun peer selezionato</div>
                    <div class="lxmf-peer-signal" id="selectedPeerSignal"></div>
                    <div class="lxmf-message-actions">
                        <button onclick="clearMessages()" title="Pulisci chat">üóëÔ∏è</button>
                        <button onclick="toggleRawView()" id="rawViewBtn" class="lxmf-raw-toggle" title="Mostra HEX/ASCII messaggi">üî¨ RAW</button>
                        <button onclick="toggleMonitor()" id="monitorBtn" class="lxmf-raw-toggle" title="Monitor pacchetti e telemetria">üìä MONITOR</button>
                        <button onclick="exportConversation()" title="Esporta conversazione">üì•</button>
                    </div>
                </div>
                
                <!-- LISTA MESSAGGI -->
                <div class="lxmf-message-list" id="messageList">
                    <div class="lxmf-no-peer">üëà Seleziona un peer per iniziare</div>
                </div>
                
                <!-- Area anteprima file -->
                <div id="filePreview" class="lxmf-file-preview"></div>
                
                <!-- INPUT AREA -->
                <div class="lxmf-input-area">
                    <input type="text" 
                           id="messageInput" 
                           placeholder="Scrivi messaggio... (Invio per inviare)" 
                           autocomplete="off"
                           disabled>
                    <button class="lxmf-file-btn" id="fileBtn" onclick="document.getElementById('fileInput').click()" disabled title="Allega file">üìé</button>
                    <button id="sendButton" onclick="sendMessage()" disabled>INVIA</button>
                    <input type="file" id="fileInput" class="lxmf-file-input" onchange="handleFileSelect()">
                </div>
                
                <!-- Statistiche trasferimento -->
                <div class="lxmf-transfer-stats" id="transferStats"></div>
                
                <div class="lxmf-shortcut-hint">
                    Enter per inviare | üìé per allegati | üî¨ RAW per HEX/ASCII
                </div>
            </div>

            <!-- COLONNA 3 - MONITOR PACCHETTI (30% quando attivo) -->
            <div class="lxmf-raw-monitor" id="rawMonitor">
                <!-- Header fisso con titolo e pulsante -->
                <div class="lxmf-raw-header">
                    <h3>üì° TELEMETRIA & MAPPA</h3>
                    <button onclick="clearMonitorLog()" class="lxmf-raw-clear">Pulisci</button>
                </div>
                
                <!-- AREA FISSA 60% - TELEMETRIA + MAPPA -->
                <div class="telemetry-fixed-area" id="telemetryFixedArea">
                    <!-- DASHBOARD TELEMETRIA MIGLIORATA -->
                    <div class="peer-telemetry" id="telemetryDashboard">
                        <div class="telemetry-empty">üëà Seleziona un peer per vedere i dati</div>
                    </div>
                    
                    <!-- MAPPA INTEGRATA CON CONTROLLI -->
                    <div class="telemetry-map" id="telemetryMap">
                        <div class="map-controls">
                            <button class="map-style-btn active" onclick="setMapStyle('topo')" id="mapStyleTopo">üó∫Ô∏è Rilievi</button>
                            <button class="map-style-btn" onclick="setMapStyle('satellite')" id="mapStyleSatellite">üõ∞Ô∏è Satellite</button>
                            <button class="map-style-btn" onclick="setMapStyle('street')" id="mapStyleStreet">üèôÔ∏è Strade</button>
                        </div>
                        <div class="map-placeholder" id="mapPlaceholder">
                            <span>üó∫Ô∏è Nessuna posizione disponibile</span>
                        </div>
                        <div id="mapContainer" class="map-container" style="display: none;"></div>
                    </div>
                </div>
                
                <!-- Header per pacchetti raw -->
                <div class="lxmf-raw-header" style="border-top: 1px solid #444;">
                    <h3>üì¶ PACCHETTI RAW</h3>
                    <span id="packetCount">0</span>
                </div>
                
                <!-- LISTA PACCHETTI SCORREVOLE - 40% RESTO -->
                <div class="lxmf-raw-list" id="rawContent">
                    <div style="color: #888; text-align: center; margin-top: 20px;">Nessun pacchetto ricevuto</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // STATO GLOBALE
        // ============================================
        let currentIdentity = null;
        let currentPeer = null;
        let peers = [];
        let messages = [];
        let pollInterval = null;
        let peerInterval = null;
        let progressInterval = null;
        let lastMessagesJson = '';
        let sortMode = 'time';
        let timeOrder = 'desc';
        let hopsOrder = 'asc';
        let signalOrder = 'desc';
        let selectedFiles = [];
        let activeTransfers = new Map();

        // RAW view - per i messaggi
        let rawViewActive = false;

        // Monitor - per pacchetti in tempo reale
        let monitorActive = false;
        let incomingPackets = {};

        // Notifiche peer
        let unreadPeers = new Set();

        // Database telemetria per peer
        let telemetryDatabase = {};

        // Mappa Leaflet
        let mapInstance = null;
        let mapMarker = null;
        let currentMapStyle = 'topo';

        // Cache messaggi per debug
        let messageCache = new Map();
        let debugLogs = [];

        // ============================================
        // FUNZIONI DI DEBUG
        // ============================================
        function debugLog(message, data = null) {
            const time = new Date().toLocaleTimeString();
            const logEntry = `[${time}] ${message}` + (data ? `: ${JSON.stringify(data).substring(0, 200)}` : '');
            
            console.log('üîç DEBUG:', logEntry);
            
            debugLogs.unshift(logEntry);
            if (debugLogs.length > 50) debugLogs.pop();
            
            const debugContent = document.getElementById('debugContent');
            if (debugContent) {
                let html = '';
                debugLogs.slice(0, 20).forEach(log => {
                    html += `<div style="border-bottom: 1px solid #333; padding: 2px 0; color: #0f0;">${escapeHtml(log)}</div>`;
                });
                debugContent.innerHTML = html;
            }
        }

        // ============================================
        // PARSING MESSAGGI TELEMETRIA
        // ============================================
        function parseTelemetryMessage(text) {
            if (!text || typeof text !== 'string') return { type: 'text', content: text };
            
            debugLog('Parsing messaggio:', text.substring(0, 100));
            
            // Parsing messaggi Arg0net TelemetryBot
            if (text.includes('Uptime:') && text.includes('CPU:') && text.includes('RAM:')) {
                debugLog('Rilevato messaggio TelemetryBot');
                
                // Estrai valori con regex
                const uptimeMatch = text.match(/Uptime:\s*([^ ]+\s+[^ ]+)/);
                const cpuMatch = text.match(/CPU:\s*([0-9.]+%)/);
                const ramMatch = text.match(/RAM:\s*([0-9.]+%)/);
                const diskMatch = text.match(/Disk:\s*([0-9.]+%)/);
                const netMatch = text.match(/Net sent:\s*([0-9]+) KB,\s*recv:\s*([0-9]+) KB/);
                
                const data = {
                    uptime: uptimeMatch ? uptimeMatch[1] : null,
                    cpu: cpuMatch ? cpuMatch[1] : null,
                    ram: ramMatch ? ramMatch[1] : null,
                    disk: diskMatch ? diskMatch[1] : null,
                    net_sent: netMatch ? netMatch[1] : null,
                    net_recv: netMatch ? netMatch[2] : null
                };
                
                debugLog('Dati TelemetryBot estratti:', data);
                return { type: 'telemetry', data, raw: text };
            }
            
            // Parsing messaggi con valori chiave: valore
            if (text.includes(':')) {
                const lines = text.split('\n');
                const data = {};
                let structured = false;
                
                lines.forEach(line => {
                    const parts = line.split(':');
                    if (parts.length >= 2) {
                        const key = parts[0].trim();
                        const value = parts.slice(1).join(':').trim();
                        if (key && value && !key.includes(' ') && value.length < 50) {
                            data[key] = value;
                            structured = true;
                        }
                    }
                });
                
                if (structured && Object.keys(data).length > 1) {
                    debugLog('Messaggio strutturato:', data);
                    return { type: 'structured', data, raw: text };
                }
            }
            
            // Se contiene molti spazi, formatta su pi√π righe
            if (text.split(' ').length > 10 && text.length > 80) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                words.forEach(word => {
                    if ((currentLine + ' ' + word).length < 40) {
                        currentLine += (currentLine ? ' ' : '') + word;
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                });
                if (currentLine) lines.push(currentLine);
                
                return { type: 'wrapped', lines, raw: text };
            }
            
            return { type: 'text', content: text };
        }

        function formatMessageContent(msg) {
            if (!msg || !msg.content) return '';
            
            const parsed = parseTelemetryMessage(msg.content);
            
            if (parsed.type === 'telemetry' && parsed.data) {
                const d = parsed.data;
                let html = '<div class="message-telemetry">';
                html += '<div style="color: #88ff88; font-weight: bold; margin-bottom: 4px;">üìä TELEMETRY BOT</div>';
                html += '<div class="message-telemetry-row">';
                
                if (d.uptime) html += `<span><span style="color:#888;">‚è±Ô∏è</span> ${d.uptime}</span>`;
                if (d.cpu) html += `<span><span style="color:#888;">CPU</span> ${d.cpu}</span>`;
                if (d.ram) html += `<span><span style="color:#888;">RAM</span> ${d.ram}</span>`;
                if (d.disk) html += `<span><span style="color:#888;">DISK</span> ${d.disk}</span>`;
                
                html += '</div><div class="message-telemetry-row" style="margin-top:4px;">';
                
                if (d.net_sent) html += `<span><span style="color:#888;">üì§</span> ${d.net_sent} KB</span>`;
                if (d.net_recv) html += `<span><span style="color:#888;">üì•</span> ${d.net_recv} KB</span>`;
                
                html += '</div></div>';
                return html;
            }
            
            if (parsed.type === 'structured' && parsed.data) {
                const d = parsed.data;
                let html = '<div class="message-telemetry">';
                html += '<div class="message-telemetry-row">';
                
                for (let [key, value] of Object.entries(d)) {
                    html += `<span><span style="color:#888;">${key}</span> ${value}</span>`;
                }
                
                html += '</div></div>';
                return html;
            }
            
            if (parsed.type === 'wrapped' && parsed.lines) {
                let html = '<div class="lxmf-message-content formatted">';
                parsed.lines.forEach(line => {
                    html += escapeHtml(line) + '<br>';
                });
                html += '</div>';
                return html;
            }
            
            return `<div class="lxmf-message-content">${escapeHtml(parsed.content || msg.content)}</div>`;
        }

        // ============================================
        // FUNZIONI DI UTILITY
        // ============================================
        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            statusEl.className = `status ${status}`;
        }

        function updateIdentityDisplay() {
            if (currentIdentity) {
                console.log("üÜî Aggiorno display identit√†:", currentIdentity);
                
                // Header (in alto a destra) - Nome
                document.getElementById('identityStatus').innerHTML = '‚úÖ';
                document.getElementById('identityName').innerHTML = currentIdentity.name || 'Sconosciuto';
                
                // IDENTITY HASH in alto a destra
                if (currentIdentity.identity_hash) {
                    // Pulisci solo caratteri problematici, NON TAGLIARE
                    let identityHash = currentIdentity.identity_hash;
                    identityHash = identityHash.replace(/[<>:\s]/g, '');
                    document.getElementById('identityHash').innerHTML = identityHash.substring(0, 32);
                    console.log("üìá Header identity hash:", identityHash.substring(0, 32));
                } else {
                    document.getElementById('identityHash').innerHTML = '';
                }
                
                // Sidebar (sopra lista peer) - Nome
                document.getElementById('sidebarIdentityName').innerHTML = currentIdentity.name || '-';
                document.getElementById('sidebarAspect').innerHTML = 'üîó lxmf.delivery';

                // DELIVERY HASH nella sidebar (campo nero) - QUESTO √à QUELLO CHE MANCAVA!
                if (currentIdentity.delivery_hash) {
                    // Pulisci solo caratteri problematici
                    let deliveryHash = currentIdentity.delivery_hash;
                    deliveryHash = deliveryHash.replace(/[<>:\s]/g, '');
                    document.getElementById('sidebarDeliveryHash').innerHTML = deliveryHash.substring(0, 32);
                    console.log("üì¶ Sidebar delivery hash:", deliveryHash.substring(0, 32));
                } else {
                    document.getElementById('sidebarDeliveryHash').innerHTML = '';
                    console.log("‚ö†Ô∏è Nessun delivery_hash in currentIdentity");
                    
                    // Fallback: prova a usare address
                    if (currentIdentity.address) {
                        let address = currentIdentity.address.replace(/[<>:\s]/g, '');
                        document.getElementById('sidebarDeliveryHash').innerHTML = address.substring(0, 32);
                        console.log("‚ö†Ô∏è Usato address come fallback per delivery");
                    }
                }
                
                // Identity hash piccolo sotto (se vuoi mostrarlo anche l√¨)
                if (currentIdentity.identity_hash) {
                    let identityHash = currentIdentity.identity_hash.replace(/[<>:\s]/g, '');
                    document.getElementById('sidebarIdentityHash').innerHTML = identityHash.substring(0, 32);
                } else {
                    document.getElementById('sidebarIdentityHash').innerHTML = '';
                }
            } else {
                console.log("‚ö†Ô∏è currentIdentity √® null in updateIdentityDisplay");
            }
        }

        function formatBytes(bytes) {
            if (!bytes || bytes === 0 || isNaN(bytes)) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function formatSpeed(bytesPerSec) {
            if (!bytesPerSec || bytesPerSec < 0 || isNaN(bytesPerSec)) return '';
            const bitsPerSec = bytesPerSec * 8;
            if (bitsPerSec < 1000) return bitsPerSec.toFixed(1) + ' b/s';
            if (bitsPerSec < 1000000) return (bitsPerSec/1000).toFixed(1) + ' Kb/s';
            return (bitsPerSec/1000000).toFixed(2) + ' Mb/s';
        }

        function formatElapsed(seconds) {
            if (!seconds || seconds < 0 || isNaN(seconds)) return '';
            if (seconds < 60) return seconds.toFixed(1) + 's';
            if (seconds < 3600) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}m ${secs}s`;
            }
            return `${Math.floor(seconds/3600)}h ${Math.floor((seconds%3600)/60)}m`;
        }

        function getSignalClass(value, type) {
            if (value === undefined || value === null) return '';
            if (type === 'rssi') {
                if (value > -70) return 'good';
                if (value > -85) return 'fair';
                return 'poor';
            } else if (type === 'snr') {
                if (value > 15) return 'good';
                if (value > 8) return 'fair';
                return 'poor';
            }
            return '';
        }

        function cleanHash(hash) {
            if (!hash) return '';
            return hash.replace(/[:\s<>]/g, '').toLowerCase();
        }

        function cleanDisplayName(name) {
            if (!name) return 'Sconosciuto';
            let cleanName = String(name);
            cleanName = cleanName.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
            cleanName = cleanName.replace(/\s+/g, ' ').trim();
            if (!cleanName || cleanName.length === 0) return 'Sconosciuto';
            return cleanName;
        }

        function getTimeAgo(ts) {
            if (!ts) return 'sconosciuto';
            const seconds = Math.floor((Date.now() / 1000) - ts);
            if (seconds < 60) return 'ora';
            if (seconds < 3600) return `${Math.floor(seconds/60)}m fa`;
            if (seconds < 86400) return `${Math.floor(seconds/3600)}h fa`;
            return `${Math.floor(seconds/86400)}g fa`;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // ============================================
        // FUNZIONI MAPPA LEAFLET
        // ============================================
        function initMap() {
            const mapContainer = document.getElementById('mapContainer');
            const mapPlaceholder = document.getElementById('mapPlaceholder');
            
            if (!mapContainer) return;
            
            mapPlaceholder.style.display = 'none';
            mapContainer.style.display = 'block';
            
            if (!mapInstance) {
                mapInstance = L.map('mapContainer').setView([41.9028, 12.4964], 5);
                
                // Mappa predefinita - rilievi (OpenTopoMap)
                L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenTopoMap',
                    maxZoom: 17,
                    opacity: 1
                }).addTo(mapInstance);
                
                mapMarker = L.marker([41.9028, 12.4964], {
                    icon: L.divIcon({
                        className: 'custom-marker',
                        html: 'üì°',
                        iconSize: [30, 30],
                        popupAnchor: [0, -15]
                    })
                }).addTo(mapInstance);
                
                mapMarker.setOpacity(0);
                debugLog('Mappa inizializzata con stile rilievi');
            }
        }

        function setMapStyle(style) {
            currentMapStyle = style;
            
            // Aggiorna pulsanti
            document.getElementById('mapStyleTopo').classList.toggle('active', style === 'topo');
            document.getElementById('mapStyleSatellite').classList.toggle('active', style === 'satellite');
            document.getElementById('mapStyleStreet').classList.toggle('active', style === 'street');
            
            if (!mapInstance) {
                initMap();
                return;
            }
            
            // Rimuovi tutti i layer esistenti
            mapInstance.eachLayer(layer => {
                if (layer instanceof L.TileLayer) {
                    mapInstance.removeLayer(layer);
                }
            });
            
            // Aggiungi il nuovo layer in base allo stile
            let tileLayer;
            
            switch(style) {
                case 'satellite':
                    tileLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        attribution: '&copy; Esri',
                        maxZoom: 18
                    });
                    break;
                case 'street':
                    tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; OpenStreetMap',
                        maxZoom: 19
                    });
                    break;
                case 'topo':
                default:
                    tileLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; OpenTopoMap',
                        maxZoom: 17
                    });
                    break;
            }
            
            tileLayer.addTo(mapInstance);
            
            // Riaggiungi il marker se esiste
            if (mapMarker) {
                mapMarker.addTo(mapInstance);
            }
            
            debugLog('Stile mappa cambiato:', style);
        }

        function updateMap(lat, lon) {
            const mapContainer = document.getElementById('mapContainer');
            const mapPlaceholder = document.getElementById('mapPlaceholder');
            
            if (!lat || !lon) {
                if (mapContainer) mapContainer.style.display = 'none';
                if (mapPlaceholder) {
                    mapPlaceholder.style.display = 'flex';
                    mapPlaceholder.innerHTML = '<span>üó∫Ô∏è Posizione non disponibile</span>';
                }
                return;
            }
            
            mapContainer.style.display = 'block';
            mapPlaceholder.style.display = 'none';
            
            if (!mapInstance) {
                initMap();
            }
            
            if (mapInstance && mapMarker) {
                mapInstance.setView([lat, lon], 13);
                mapMarker.setLatLng([lat, lon]);
                mapMarker.setOpacity(1);
                
                mapMarker.bindPopup(`
                    <div style="color: #000; font-family: monospace;">
                        <strong>üìç ${escapeHtml(currentPeer?.display_name || 'Peer')}</strong><br>
                        Lat: ${lat.toFixed(6)}¬∞<br>
                        Lon: ${lon.toFixed(6)}¬∞
                    </div>
                `).openPopup();
                
                debugLog('Mappa aggiornata', { lat, lon });
            }
        }

        // ============================================
        // TELEMETRIA DASHBOARD MIGLIORATA
        // ============================================
        function saveTelemetryToDatabase(peerHash, telemetryData) {
            if (!peerHash || !telemetryData) return;
            
            if (!telemetryDatabase[peerHash]) {
                telemetryDatabase[peerHash] = {
                    battery: null,
                    location: null,
                    appearance: null,
                    information: null,
                    pressure: null,
                    temperature: null,
                    humidity: null,
                    lastUpdate: null,
                    history: []
                };
            }
            
            // Aggiorna i dati
            if (telemetryData.battery) telemetryDatabase[peerHash].battery = telemetryData.battery;
            if (telemetryData.location) telemetryDatabase[peerHash].location = telemetryData.location;
            if (telemetryData.appearance) telemetryDatabase[peerHash].appearance = telemetryData.appearance;
            if (telemetryData.information) telemetryDatabase[peerHash].information = telemetryData.information;
            if (telemetryData.pressure) telemetryDatabase[peerHash].pressure = telemetryData.pressure;
            if (telemetryData.temperature) telemetryDatabase[peerHash].temperature = telemetryData.temperature;
            if (telemetryData.humidity) telemetryDatabase[peerHash].humidity = telemetryData.humidity;
            
            telemetryDatabase[peerHash].lastUpdate = telemetryData.timestamp || Math.floor(Date.now() / 1000);
            
            // Salva nello storico (max 100 entry)
            if (!telemetryDatabase[peerHash].history) {
                telemetryDatabase[peerHash].history = [];
            }
            
            telemetryDatabase[peerHash].history.unshift({
                timestamp: telemetryData.timestamp || Math.floor(Date.now() / 1000),
                battery: telemetryData.battery?.charge_percent,
                location: telemetryData.location
            });
            
            if (telemetryDatabase[peerHash].history.length > 100) {
                telemetryDatabase[peerHash].history.pop();
            }
            
            debugLog('Telemetria salvata per peer', { peer: peerHash.substring(0,8), data: telemetryData });
        }

        function getTelemetryFromDatabase(peerHash) {
            if (!peerHash || !telemetryDatabase[peerHash]) {
                return {
                    battery: null,
                    location: null,
                    appearance: null,
                    information: null,
                    pressure: null,
                    temperature: null,
                    humidity: null,
                    lastUpdate: null
                };
            }
            
            return telemetryDatabase[peerHash];
        }

        function renderTelemetryDashboard() {
            const dashboard = document.getElementById('telemetryDashboard');
            const mapPlaceholder = document.getElementById('mapPlaceholder');
            const mapContainer = document.getElementById('mapContainer');
            
            if (!dashboard) return;
            
            if (!currentPeer) {
                dashboard.innerHTML = '<div class="telemetry-empty">üëà Seleziona un peer</div>';
                return;
            }
            
            const peerHash = cleanHash(currentPeer.hash);
            const telemetry = getTelemetryFromDatabase(peerHash);
            
            if (!telemetry.battery && !telemetry.location && !telemetry.appearance && !telemetry.information) {
                dashboard.innerHTML = '<div class="telemetry-empty">üì° Nessun dato telemetria disponibile per questo peer</div>';
                
                if (mapContainer) mapContainer.style.display = 'none';
                if (mapPlaceholder) {
                    mapPlaceholder.style.display = 'flex';
                    mapPlaceholder.innerHTML = '<span>üó∫Ô∏è Nessuna posizione</span>';
                }
                return;
            }
            
            // Costruisci la dashboard migliorata
            let html = '<div class="telemetry-dashboard">';
            
            // Header con icona MDI
            const iconName = telemetry.appearance?.icon || 'account';
            html += `<div class="telemetry-peer-header">`;
            html += `<div class="telemetry-peer-icon"><span class="mdi mdi-${iconName}"></span></div>`;
            html += `<div class="telemetry-peer-info">`;
            html += `<div class="telemetry-peer-name">${escapeHtml(cleanDisplayName(currentPeer.display_name))}</div>`;
            html += `<div class="telemetry-peer-hash">${peerHash.substring(0, 16)}...</div>`;
            html += `</div></div>`;
            
            // Griglia telemetria
            html += `<div class="telemetry-grid">`;
            
            // Batteria
            if (telemetry.battery) {
                const battery = telemetry.battery;
                const chargePercent = battery.charge_percent || battery.charge || 0;
                const isCharging = battery.charging || false;
                const batteryIcon = isCharging ? 'mdi-lightning-bolt' : (chargePercent > 20 ? 'mdi-battery' : 'mdi-battery-outline');
                
                html += `<div class="telemetry-card">`;
                html += `<div class="telemetry-card-title"><span class="mdi ${batteryIcon}"></span> BATTERIA</div>`;
                html += `<div class="telemetry-card-content">`;
                html += `<div class="battery-level">`;
                html += `<div class="battery-bar"><div class="battery-fill" style="width: ${chargePercent}%;"></div></div>`;
                html += `<span class="battery-text">${chargePercent}%</span>`;
                html += `</div>`;
                if (battery.temperature) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Temperatura</span><span class="telemetry-data-value">${battery.temperature}¬∞C</span></div>`;
                }
                if (battery.voltage) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Tensione</span><span class="telemetry-data-value">${battery.voltage}V</span></div>`;
                }
                html += `</div></div>`;
            }
            
            // Posizione
            if (telemetry.location) {
                const loc = telemetry.location;
                html += `<div class="telemetry-card">`;
                html += `<div class="telemetry-card-title"><span class="mdi mdi-map-marker"></span> POSIZIONE</div>`;
                html += `<div class="telemetry-card-content">`;
                html += `<div class="location-badge">`;
                html += `<div class="location-coord"><span>Lat:</span><span class="telemetry-data-value">${loc.latitude?.toFixed(6) || '?'}</span></div>`;
                html += `<div class="location-coord"><span>Lon:</span><span class="telemetry-data-value">${loc.longitude?.toFixed(6) || '?'}</span></div>`;
                if (loc.altitude) {
                    html += `<div class="location-coord"><span>Alt:</span><span class="telemetry-data-value">${loc.altitude.toFixed(1)}m</span></div>`;
                }
                if (loc.accuracy) {
                    html += `<div class="location-coord"><span>Acc:</span><span class="telemetry-data-value">¬±${loc.accuracy.toFixed(1)}m</span></div>`;
                }
                if (loc.speed !== undefined && !isNaN(loc.speed)) {
                    html += `<div class="location-coord"><span>Vel:</span><span class="telemetry-data-value">${(loc.speed * 3.6).toFixed(1)} km/h</span></div>`;
                }
                if (loc.bearing !== undefined && !isNaN(loc.bearing)) {
                    html += `<div class="location-coord"><span>Dir:</span><span class="telemetry-data-value">${loc.bearing.toFixed(0)}¬∞</span></div>`;
                }
                html += `</div></div></div>`;
                
                // Aggiorna mappa
                if (loc.latitude && loc.longitude) {
                    updateMap(loc.latitude, loc.longitude);
                }
            }
            
            // Informazioni di sistema
            if (telemetry.information || telemetry.pressure || telemetry.temperature || telemetry.humidity) {
                html += `<div class="telemetry-card">`;
                html += `<div class="telemetry-card-title"><span class="mdi mdi-information"></span> SISTEMA</div>`;
                html += `<div class="telemetry-card-content">`;
                
                if (telemetry.temperature) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Temperatura</span><span class="telemetry-data-value">${telemetry.temperature}¬∞C</span></div>`;
                }
                if (telemetry.humidity) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Umidit√†</span><span class="telemetry-data-value">${telemetry.humidity}%</span></div>`;
                }
                if (telemetry.pressure) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Pressione</span><span class="telemetry-data-value">${telemetry.pressure} hPa</span></div>`;
                }
                if (telemetry.information?.uptime) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Uptime</span><span class="telemetry-data-value">${telemetry.information.uptime}</span></div>`;
                }
                if (telemetry.information?.cpu) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">CPU</span><span class="telemetry-data-value">${telemetry.information.cpu}</span></div>`;
                }
                if (telemetry.information?.ram) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">RAM</span><span class="telemetry-data-value">${telemetry.information.ram}</span></div>`;
                }
                if (telemetry.information?.disk) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Disk</span><span class="telemetry-data-value">${telemetry.information.disk}</span></div>`;
                }
                
                html += `</div></div>`;
            }
            
            // Aspetto/Icona
            if (telemetry.appearance) {
                html += `<div class="telemetry-card">`;
                html += `<div class="telemetry-card-title"><span class="mdi mdi-palette"></span> ASPETTO</div>`;
                html += `<div class="telemetry-card-content">`;
                
                if (telemetry.appearance.icon) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Icona</span><span class="telemetry-data-value"><span class="mdi mdi-${telemetry.appearance.icon}"></span> ${telemetry.appearance.icon}</span></div>`;
                }
                if (telemetry.appearance.color) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Colore</span><span class="telemetry-data-value" style="color:${telemetry.appearance.color};">${telemetry.appearance.color}</span></div>`;
                }
                if (telemetry.appearance.name) {
                    html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Nome</span><span class="telemetry-data-value">${escapeHtml(telemetry.appearance.name)}</span></div>`;
                }
                
                html += `</div></div>`;
            }
            
            // Ultimo aggiornamento
            if (telemetry.lastUpdate) {
                const date = new Date(telemetry.lastUpdate * 1000);
                html += `<div class="telemetry-card">`;
                html += `<div class="telemetry-card-title"><span class="mdi mdi-clock-outline"></span> ULTIMO AGGIORNAMENTO</div>`;
                html += `<div class="telemetry-card-content">`;
                html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Data</span><span class="telemetry-data-value">${date.toLocaleDateString()}</span></div>`;
                html += `<div class="telemetry-data-row"><span class="telemetry-data-label">Ora</span><span class="telemetry-data-value">${date.toLocaleTimeString()}</span></div>`;
                html += `</div></div>`;
            }
            
            html += `</div>`; // Chiudi griglia
            
            // Storico batteria (se disponibile)
            if (telemetry.history && telemetry.history.length > 1) {
                html += `<div class="telemetry-divider"></div>`;
                html += `<div class="telemetry-card-title"><span class="mdi mdi-chart-line"></span> STORICO BATTERIA</div>`;
                html += `<div class="info-grid">`;
                
                // Mostra ultimi 4 valori
                telemetry.history.slice(0, 4).forEach((entry, index) => {
                    if (entry.battery) {
                        const entryDate = new Date(entry.timestamp * 1000);
                        html += `<div class="info-item">`;
                        html += `<div class="info-label">${entryDate.toLocaleTimeString()}</div>`;
                        html += `<div class="info-value">${entry.battery}%</div>`;
                        html += `</div>`;
                    }
                });
                
                html += `</div>`;
            }
            
            html += `</div>`;
            dashboard.innerHTML = html;
        }

        // ============================================
        // PULSANTI
        // ============================================
        function toggleRawView() {
            rawViewActive = !rawViewActive;
            const btn = document.getElementById('rawViewBtn');
            
            if (rawViewActive) {
                btn.classList.add('active');
                btn.innerHTML = 'üî¨ RAW ON';
            } else {
                btn.classList.remove('active');
                btn.innerHTML = 'üî¨ RAW';
            }
            renderMessages();
            debugLog('RAW view', rawViewActive);
        }

        function toggleMonitor() {
            monitorActive = !monitorActive;
            const monitor = document.getElementById('rawMonitor');
            const btn = document.getElementById('monitorBtn');
            const container = document.getElementById('chatContainer');
            const messageColumn = document.querySelector('.lxmf-message-column');
            
            if (monitorActive) {
                monitor.style.display = 'flex';
                container.classList.add('monitor-active');
                btn.classList.add('active');
                btn.innerHTML = 'üìä MONITOR ON';
                messageColumn.style.flex = '1';
                renderMonitorPackets();
                renderTelemetryDashboard();
            } else {
                monitor.style.display = 'none';
                container.classList.remove('monitor-active');
                btn.classList.remove('active');
                btn.innerHTML = 'üìä MONITOR';
                messageColumn.style.flex = '3';
            }
            debugLog('Monitor', monitorActive);
        }

        // ============================================
        // FUNZIONI MONITOR
        // ============================================
        function addMonitorPacket(packet) {
            if (!packet.peer) return;
            
            const packetPeer = cleanHash(packet.peer);
            const currentPeerHash = currentPeer ? cleanHash(currentPeer.hash) : null;
            
            if (packet.direction !== 'incoming') {
                return;
            }
            
            if (!incomingPackets[packetPeer]) {
                incomingPackets[packetPeer] = [];
            }
            
            const recentPackets = incomingPackets[packetPeer].slice(0, 5);
            const isDuplicate = recentPackets.some(p => 
                p.timestamp === packet.timestamp && 
                p.content === packet.content &&
                p.raw_hex === packet.raw_hex
            );
            
            if (isDuplicate) {
                return;
            }
            
            incomingPackets[packetPeer].unshift(packet);
            
            if (incomingPackets[packetPeer].length > 50) {
                incomingPackets[packetPeer].pop();
            }
            
            // Estrai dati telemetria dal pacchetto
            const telemetryData = {
                timestamp: packet.timestamp,
                battery: packet.battery,
                location: packet.location,
                appearance: packet.appearance,
                information: packet.information,
                pressure: packet.pressure,
                temperature: packet.temperature,
                humidity: packet.humidity
            };
            
            // Se ci sono dati nel pacchetto, aggiungili
            if (packet.telemetry) {
                if (packet.telemetry.battery) telemetryData.battery = packet.telemetry.battery;
                if (packet.telemetry.location) telemetryData.location = packet.telemetry.location;
                if (packet.telemetry.appearance) telemetryData.appearance = packet.telemetry.appearance;
                if (packet.telemetry.information) telemetryData.information = packet.telemetry.information;
            }
            
            // Salva nel database
            saveTelemetryToDatabase(packetPeer, telemetryData);
            
            if (currentPeerHash && packetPeer === currentPeerHash) {
                if (monitorActive) {
                    renderTelemetryDashboard();
                    renderMonitorPackets();
                    document.getElementById('packetCount').textContent = incomingPackets[packetPeer].length;
                }
            }
            
            if (currentPeerHash && packetPeer !== currentPeerHash) {
                unreadPeers.add(packetPeer);
                renderPeerList();
            }
        }

        function clearMonitorLog() {
            if (!currentPeer) return;
            const peerHash = cleanHash(currentPeer.hash);
            incomingPackets[peerHash] = [];
            
            document.getElementById('packetCount').textContent = '0';
            if (monitorActive) {
                renderMonitorPackets();
            }
            debugLog('Monitor log pulito');
        }

        function renderMonitorPackets() {
            const list = document.getElementById('rawContent');
            if (!list || !currentPeer) return;
            
            const currentPeerHash = cleanHash(currentPeer.hash);
            const packets = incomingPackets[currentPeerHash] || [];
            
            if (packets.length === 0) {
                list.innerHTML = '<div style="color: #888; text-align: center; margin-top: 20px;">Nessun pacchetto ricevuto</div>';
                return;
            }
            
            let html = '';
            packets.slice(0, 30).forEach(pkt => {
                const time = new Date(pkt.timestamp * 1000).toLocaleTimeString();
                const date = new Date(pkt.timestamp * 1000).toLocaleDateString();
                
                html += `<div style="border-bottom:1px solid #333; padding:6px; font-size:10px;">`;
                html += `<div style="color:#888;">${date} ${time} üì•</div>`;
                
                if (pkt.content) {
                    const short = pkt.content.length > 50 ? pkt.content.substring(0,50) + '...' : pkt.content;
                    html += `<div style="color:#88ff88;">${escapeHtml(short)}</div>`;
                }
                
                // Mostra RAW HEX e ASCII se disponibili (questa parte era stata tagliata!)
                if (pkt.raw_hex) {
                    html += `<div style="color:#88f; font-size:8px; margin-top:2px;">HEX: ${pkt.raw_hex.substring(0, 100)}${pkt.raw_hex.length > 100 ? '...' : ''}</div>`;
                }
                if (pkt.raw_ascii) {
                    html += `<div style="color:#ff8; font-size:8px;">ASCII: ${escapeHtml(pkt.raw_ascii.substring(0, 100))}${pkt.raw_ascii.length > 100 ? '...' : ''}</div>`;
                }
                
                if (pkt.rssi || pkt.snr) {
                    html += `<div style="display:flex; gap:8px; margin-top:2px;">`;
                    if (pkt.rssi) html += `<span>üì∂ ${pkt.rssi.toFixed(1)}</span>`;
                    if (pkt.snr) html += `<span>üìä ${pkt.snr.toFixed(1)}</span>`;
                    html += `</div>`;
                }
                
                // Mostra badge se ci sono dati telemetria
                if (pkt.battery || pkt.location) {
                    html += `<div style="display:flex; gap:4px; margin-top:2px;">`;
                    if (pkt.battery) html += `<span style="color:#7ec8e0;">üîã ${pkt.battery.charge_percent || pkt.battery.charge || '?'}%</span>`;
                    if (pkt.location) html += `<span style="color:#7ec8e0;">üìç pos</span>`;
                    html += `</div>`;
                }
                
                html += `</div>`;
            });
            
            list.innerHTML = html;
        }

        // ============================================
        // API: GESTIONE IDENTIT√Ä
        // ============================================
        async function loadIdentities() {
            try {
                debugLog('Caricamento identit√†...');
                const r = await fetch('/api/chat/identities');
                const identities = await r.json();
                
                debugLog('Identit√† ricevute', identities);
                
                const select = document.getElementById('identitySelect');
                
                if (!identities || identities.length === 0) {
                    select.innerHTML = '<option value="">‚ùå Nessuna identit√† trovata</option>';
                    return;
                }
                
                let html = '<option value="">üìÅ Scegli identit√†...</option>';
                identities.forEach(id => {
                    let shortHash = id.hash ? id.hash.replace(/[<>]/g, '').substring(0, 8) : '';
                    html += `<option value="${id.path}">${id.name} (${shortHash})</option>`;
                });
                select.innerHTML = html;
                
            } catch (e) {
                debugLog('Errore caricamento identit√†', e.message);
                document.getElementById('identitySelect').innerHTML = '<option value="">‚ùå Errore caricamento</option>';
            }
        }

        async function selectIdentity() {
            const path = document.getElementById('identitySelect').value;
            if (!path) return;
            
            const btn = document.getElementById('initButton');
            const status = document.getElementById('initStatus');
            
            btn.disabled = true;
            status.innerHTML = '‚è≥ Inizializzazione...';
            
            try {
                debugLog('Selezione identit√†', path);
                
                const r = await fetch('/api/chat/identities/select', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({path})
                });
                const data = await r.json();
                
                debugLog('Risposta select', data);
                
                if (data.error) throw new Error(data.error);
                
                // SALVA TUTTO, delivery_hash incluso!
                currentIdentity = {
                    name: data.identity.name,
                    path: path,
                    identity_hash: data.identity.identity_hash,
                    delivery_hash: data.identity.delivery_hash,
                    address: data.identity.address
                };
                
                // Se manca delivery_hash, usa identity_hash come fallback
                if (!currentIdentity.delivery_hash && currentIdentity.identity_hash) {
                    console.log("‚ö†Ô∏è Delivery hash mancante, uso identity_hash come fallback");
                    currentIdentity.delivery_hash = currentIdentity.identity_hash;
                }
                
                console.log("‚úÖ Identit√† caricata:", {
                    name: currentIdentity.name,
                    identity: currentIdentity.identity_hash?.substring(0, 16) + '...',
                    delivery: currentIdentity.delivery_hash?.substring(0, 16) + '...'
                });
                
                updateIdentityDisplay();
                
                document.getElementById('connectionStatus').className = 'status online';
                document.getElementById('initPanel').style.display = 'none';
                document.getElementById('chatContainer').style.display = 'flex';
                
                await loadPeers();
                peerInterval = setInterval(loadPeers, 10000);
                pollInterval = setInterval(pollMessages, 2000);
                progressInterval = setInterval(updateTransferStats, 1000);
                
                debugLog('Client avviato', currentIdentity.name);
                
            } catch (e) {
                status.innerHTML = `‚ùå Errore: ${e.message}`;
                btn.disabled = false;
                debugLog('Errore selectIdentity', e.message);
            }
        }

        // ============================================
        // API: GESTIONE PEER
        // ============================================
        async function loadPeers() {
            try {
                const r = await fetch('/api/chat/peers');
                const data = await r.json();
                peers = Array.isArray(data) ? data : (data.peers || []);
                
                debugLog('Peer caricati', peers.length);
                
                const online = peers.filter(p => p.online).length;
                const avgHops = peers.reduce((acc, p) => acc + (p.hops || 0), 0) / (peers.length || 1);
                
                document.getElementById('onlineCount').textContent = online;
                document.getElementById('avgHops').textContent = avgHops.toFixed(1);
                
                sortPeers();
                renderPeerList();
                document.getElementById('peerCountDisplay').textContent = peers.length;
                document.getElementById('peerCount').textContent = peers.length;
                
                if (peers.length > 0 && !currentPeer) {
                    const defaultPeer = peers.find(p => p.hash && p.hash.includes('04511923b68ae34e'));
                    if (defaultPeer) {
                        await selectPeer(defaultPeer.hash);
                    } else {
                        const onlinePeer = peers.find(p => p.online);
                        if (onlinePeer) {
                            await selectPeer(onlinePeer.hash);
                        } else {
                            await selectPeer(peers[0].hash);
                        }
                    }
                }
            } catch (e) {
                debugLog('Errore peers', e.message);
            }
        }

        function sortPeers() {
            if (sortMode === 'time') {
                peers.sort((a, b) => {
                    const timeA = a.last_seen || 0;
                    const timeB = b.last_seen || 0;
                    return timeOrder === 'desc' ? timeB - timeA : timeA - timeB;
                });
            } else if (sortMode === 'hops') {
                peers.sort((a, b) => {
                    const hopsA = a.hops !== undefined ? parseInt(a.hops) : 999;
                    const hopsB = b.hops !== undefined ? parseInt(b.hops) : 999;
                    return hopsOrder === 'asc' ? hopsA - hopsB : hopsB - hopsA;
                });
            } else if (sortMode === 'signal') {
                peers.sort((a, b) => {
                    let scoreA = 0, scoreB = 0, countA = 0, countB = 0;
                    
                    if (a.rssi !== undefined && !isNaN(a.rssi)) {
                        scoreA += (a.rssi + 100) * 0.6;
                        countA++;
                    }
                    if (a.snr !== undefined && !isNaN(a.snr)) {
                        scoreA += a.snr * 0.4;
                        countA++;
                    }
                    if (a.quality !== undefined && !isNaN(a.quality)) {
                        scoreA += parseFloat(a.quality);
                        countA++;
                    }
                    
                    if (b.rssi !== undefined && !isNaN(b.rssi)) {
                        scoreB += (b.rssi + 100) * 0.6;
                        countB++;
                    }
                    if (b.snr !== undefined && !isNaN(b.snr)) {
                        scoreB += b.snr * 0.4;
                        countB++;
                    }
                    if (b.quality !== undefined && !isNaN(b.quality)) {
                        scoreB += parseFloat(b.quality);
                        countB++;
                    }
                    
                    if (countA > 0) scoreA = scoreA / countA;
                    if (countB > 0) scoreB = scoreB / countB;
                    
                    if (countA === 0) scoreA = -999;
                    if (countB === 0) scoreB = -999;
                    
                    return signalOrder === 'desc' ? scoreB - scoreA : scoreA - scoreB;
                });
            }
        }

        function setSortMode(mode) {
            if (mode === 'time') {
                if (sortMode === 'time') {
                    timeOrder = timeOrder === 'desc' ? 'asc' : 'desc';
                } else {
                    sortMode = 'time';
                }
                document.getElementById('timeIcon').textContent = timeOrder === 'desc' ? '‚¨áÔ∏è' : '‚¨ÜÔ∏è';
            } else if (mode === 'hops') {
                if (sortMode === 'hops') {
                    hopsOrder = hopsOrder === 'asc' ? 'desc' : 'asc';
                } else {
                    sortMode = 'hops';
                }
                document.getElementById('hopsIcon').textContent = hopsOrder === 'asc' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
            } else if (mode === 'signal') {
                if (sortMode === 'signal') {
                    signalOrder = signalOrder === 'desc' ? 'asc' : 'desc';
                } else {
                    sortMode = 'signal';
                }
                document.getElementById('signalIcon').textContent = signalOrder === 'desc' ? '‚¨áÔ∏è' : '‚¨ÜÔ∏è';
            }
            
            document.getElementById('sortTimeBtn').classList.toggle('active', sortMode === 'time');
            document.getElementById('sortHopsBtn').classList.toggle('active', sortMode === 'hops');
            document.getElementById('sortSignalBtn').classList.toggle('active', sortMode === 'signal');
            
            sortPeers();
            renderPeerList();
            debugLog('Ordinamento', { mode: sortMode, timeOrder, hopsOrder, signalOrder });
        }

        function renderPeerList() {
            const search = document.getElementById('peerSearch').value.toLowerCase();
            let filtered = peers.filter(p => 
                (p.display_name && cleanDisplayName(p.display_name).toLowerCase().includes(search)) ||
                (p.hash && p.hash.toLowerCase().includes(search))
            );
            
            document.getElementById('peerCount').textContent = filtered.length;
            
            if (filtered.length === 0) {
                document.getElementById('peerList').innerHTML = '<div class="lxmf-no-peer">Nessun peer trovato</div>';
                return;
            }
            
            let html = '';
            filtered.forEach(peer => {
                const peerHash = cleanHash(peer.hash);
                const isSelected = currentPeer && currentPeer.hash && 
                    cleanHash(currentPeer.hash) === peerHash;
                const onlineClass = peer.online ? 'online' : 'offline';
                const timeAgo = getTimeAgo(peer.last_seen);
                const hasUnread = unreadPeers.has(peerHash);
                
                let displayName = cleanDisplayName(peer.display_name || 'Anonimo');
                if (displayName.length > 30) {
                    displayName = displayName.substring(0, 27) + '...';
                }
                
                const hashDisplay = peer.hash ? peer.hash.substring(0, 24) + '...' : 'Hash non disponibile';
                
                let signalHtml = '';
                if (peer.rssi !== undefined || peer.snr !== undefined || peer.quality !== undefined) {
                    let parts = [];
                    if (peer.rssi !== undefined && !isNaN(peer.rssi)) {
                        const rssiClass = getSignalClass(peer.rssi, 'rssi');
                        parts.push(`<span class="${rssiClass}">üì∂ ${Number(peer.rssi).toFixed(1)}</span>`);
                    }
                    if (peer.snr !== undefined && !isNaN(peer.snr)) {
                        const snrClass = getSignalClass(peer.snr, 'snr');
                        parts.push(`<span class="${snrClass}">üìä ${Number(peer.snr).toFixed(1)}</span>`);
                    }
                    if (peer.quality !== undefined && !isNaN(peer.quality)) {
                        parts.push(`‚ö° ${Number(peer.quality).toFixed(1)}`);
                    }
                    signalHtml = `<div class="lxmf-peer-signal">${parts.join(' ')}</div>`;
                }
                
                const hopsHtml = peer.hops ? 
                    `<span class="lxmf-peer-hops">${peer.hops} hop</span>` : 
                    '<span class="lxmf-peer-hops">? hop</span>';
                
                const unreadBadge = hasUnread ? '<span class="lxmf-peer-unread">‚óè</span>' : '';
                
                html += `
                    <div class="lxmf-peer-item ${onlineClass} ${isSelected ? 'selected' : ''} ${hasUnread ? 'unread' : ''}" 
                         onclick="selectPeer('${peer.hash || ''}')">
                        <div class="lxmf-peer-hash">
                            <span class="lxmf-delivery-hash">${hashDisplay}</span>
                            <span class="lxmf-peer-unread">${unreadBadge}</span>
                        </div>
                        <div class="lxmf-peer-data">${escapeHtml(displayName)}</div>
                        ${signalHtml}
                        <div class="lxmf-peer-footer">
                            <span class="lxmf-peer-time">${timeAgo}</span>
                            <span class="lxmf-peer-status">${peer.online ? 'ONLINE' : 'OFFLINE'}</span>
                            ${hopsHtml}
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('peerList').innerHTML = html;
        }

        function clearSearch() {
            document.getElementById('peerSearch').value = '';
            renderPeerList();
        }

        function refreshPeers() {
            loadPeers();
        }

        // ============================================
        // API: GESTIONE MESSAGGI
        // ============================================
        async function pollMessages() {
            if (!currentPeer) return;
            
            try {
                const peerHash = cleanHash(currentPeer.hash);
                debugLog('Poll messaggi per', peerHash.substring(0,8));
                
                const r = await fetch(`/api/chat/messages?peer=${encodeURIComponent(peerHash)}`);
                const newMessages = await r.json();
                
                debugLog('Ricevuti messaggi', { count: newMessages?.length, primo: newMessages?.[0]?.content?.substring(0,30) });
                
                // Usa JSON.stringify per il confronto
                const newMessagesJson = JSON.stringify(newMessages);
                
                if (newMessagesJson !== lastMessagesJson) {
                    lastMessagesJson = newMessagesJson;
                    
                    // Sostituisci completamente i messaggi
                    messages = newMessages;
                    
                    messageCache.set(peerHash, messages.length);
                    
                    renderMessages();
                    
                    // Aggiungi al monitor e salva telemetria (senza duplicati)
                    if (messages.length > 0) {
                        messages.forEach(msg => {
                            if (msg.direction === 'incoming') {
                                const packet = {
                                    timestamp: msg.timestamp,
                                    direction: msg.direction,
                                    peer: msg.from || msg.to,
                                    content: msg.content,
                                    rssi: msg.rssi,
                                    snr: msg.snr,
                                    q: msg.q,
                                    battery: msg.battery,
                                    location: msg.location,
                                    appearance: msg.appearance,
                                    telemetry: msg.telemetry,
                                    raw_hex: msg.raw_hex,
                                    raw_ascii: msg.raw_ascii,
                                    raw_size: msg.raw_size
                                };
                                
                                addMonitorPacket(packet);
                                
                                // Estrai e salva telemetria
                                const telemetryData = {
                                    timestamp: msg.timestamp,
                                    battery: msg.battery,
                                    location: msg.location,
                                    appearance: msg.appearance,
                                    information: msg.information
                                };
                                
                                if (msg.telemetry) {
                                    if (msg.telemetry.battery) telemetryData.battery = msg.telemetry.battery;
                                    if (msg.telemetry.location) telemetryData.location = msg.telemetry.location;
                                    if (msg.telemetry.appearance) telemetryData.appearance = msg.telemetry.appearance;
                                    if (msg.telemetry.information) telemetryData.information = msg.telemetry.information;
                                }
                                
                                saveTelemetryToDatabase(cleanHash(msg.from || msg.to), telemetryData);
                            }
                        });
                    }
                    
                    activeTransfers.clear();
                    messages.forEach(msg => {
                        if (msg.direction === 'outgoing' && msg.status === 'sending' && msg.progress < 100) {
                            activeTransfers.set(msg.id || msg.timestamp, msg);
                        }
                        if (msg.is_receiving) {
                            activeTransfers.set(msg.id || msg.timestamp, msg);
                        }
                    });
                    
                    // Aggiorna dashboard se monitor attivo
                    if (monitorActive) {
                        renderTelemetryDashboard();
                    }
                }
            } catch (e) {
                debugLog('Errore poll', e.message);
            }
        }

        async function selectPeer(hash) {
            if (!hash) return;
            
            const peerHash = cleanHash(hash);
            currentPeer = peers.find(p => p.hash && cleanHash(p.hash) === peerHash);
            
            if (currentPeer) {
                unreadPeers.delete(peerHash);
                
                debugLog('Peer selezionato', { name: currentPeer.display_name, hash: peerHash.substring(0,8) });
                
                let displayName = cleanDisplayName(currentPeer.display_name || 'Anonimo');
                if (displayName.length > 20) {
                    displayName = displayName.substring(0, 17) + '...';
                }
                
                document.getElementById('selectedPeerDisplay').innerHTML = `üì® ${escapeHtml(displayName)}`;
                
                let signalHtml = '';
                if (currentPeer.rssi !== undefined || currentPeer.snr !== undefined || currentPeer.quality !== undefined) {
                    let parts = [];
                    if (currentPeer.rssi !== undefined && !isNaN(currentPeer.rssi)) {
                        const rssiClass = getSignalClass(currentPeer.rssi, 'rssi');
                        parts.push(`<span class="${rssiClass}">RSSI: ${Number(currentPeer.rssi).toFixed(1)}</span>`);
                    }
                    if (currentPeer.snr !== undefined && !isNaN(currentPeer.snr)) {
                        const snrClass = getSignalClass(currentPeer.snr, 'snr');
                        parts.push(`<span class="${snrClass}">SNR: ${Number(currentPeer.snr).toFixed(1)}</span>`);
                    }
                    if (currentPeer.quality !== undefined && !isNaN(currentPeer.quality)) {
                        parts.push(`Q: ${Number(currentPeer.quality).toFixed(1)}`);
                    }
                    signalHtml = parts.join(' | ');
                }
                document.getElementById('selectedPeerSignal').innerHTML = signalHtml;
                
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendButton').disabled = false;
                document.getElementById('fileBtn').disabled = false;
                document.getElementById('messageInput').focus();
                
                // Resetta lastMessagesJson per forzare il refresh
                lastMessagesJson = '';
                
                await pollMessages();
                
                if (monitorActive) {
                    renderTelemetryDashboard();
                    renderMonitorPackets();
                    document.getElementById('packetCount').textContent = (incomingPackets[peerHash] || []).length;
                }
                
                renderPeerList();
            }
        }

        // ============================================
        // API: INVIO MESSAGGI
        // ============================================
        async function sendMessage() {
            if (!currentPeer) return;
            
            const input = document.getElementById('messageInput');
            const content = input.value.trim();
            
            if (!content && selectedFiles.length === 0) return;
            
            input.disabled = true;
            document.getElementById('sendButton').disabled = true;
            
            try {
                debugLog('Invio messaggio', { content: content.substring(0,30), files: selectedFiles.length });
                
                let response;
                
                if (selectedFiles.length > 0) {
                    const file = selectedFiles[0];
                    const formData = new FormData();
                    formData.append('destination', currentPeer.hash);
                    formData.append('file', file);
                    if (content) formData.append('description', content);
                    
                    response = await fetch('/api/chat/send-file', {
                        method: 'POST',
                        body: formData
                    });
                } else {
                    response = await fetch('/api/chat/send', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            destination: currentPeer.hash,
                            content: content
                        })
                    });
                }
                
                const data = await response.json();
                debugLog('Risposta invio', data);
                
                if (data.error) {
                    alert(`‚ùå Errore: ${data.error}`);
                } else if (data.success) {
                    input.value = '';
                    selectedFiles = [];
                    document.getElementById('filePreview').innerHTML = '';
                    document.getElementById('fileInput').value = '';
                    
                    // Forza refresh immediato
                    lastMessagesJson = '';
                    setTimeout(() => pollMessages(), 500);
                }
            } catch (e) {
                debugLog('Errore invio', e.message);
                alert(`‚ùå Errore: ${e.message}`);
            } finally {
                input.disabled = false;
                document.getElementById('sendButton').disabled = false;
                input.focus();
            }
        }

        // ============================================
        // FUNZIONE RIPROVA MESSAGGIO FALLITO
        // ============================================
        async function retryMessage(msg) {
            if (!currentPeer || !msg) return;
            
            debugLog('Riprova messaggio', msg);
            
            const input = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendButton');
            input.disabled = true;
            sendBtn.disabled = true;
            
            try {
                let response;
                
                if (msg.has_attachments) {
                    alert("Riprova per allegati non supportato. Invia nuovo messaggio.");
                    return;
                } else {
                    response = await fetch('/api/chat/send', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            destination: currentPeer.hash,
                            content: msg.content || ''
                        })
                    });
                }
                
                const data = await response.json();
                
                if (data.error) {
                    alert(`‚ùå Errore: ${data.error}`);
                } else if (data.success) {
                    showNotification('‚úÖ Messaggio reinviato!', 'success');
                    // Forza refresh
                    lastMessagesJson = '';
                    setTimeout(() => pollMessages(), 500);
                }
            } catch (e) {
                debugLog('Errore riprova', e.message);
                alert(`‚ùå Errore: ${e.message}`);
            } finally {
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
            }
        }

        function showNotification(message, type = 'info') {
            let notification = document.getElementById('tempNotification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'tempNotification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 24px;
                    border-radius: 4px;
                    font-weight: bold;
                    z-index: 9999;
                    animation: slideIn 0.3s ease;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(notification);
            }
            
            const colors = {
                success: { bg: '#1e3a1e', border: '#88ff88', color: '#88ff88' },
                error: { bg: '#3a1e1e', border: '#ff8888', color: '#ff8888' },
                info: { bg: '#1e3a5f', border: '#88aaff', color: '#88aaff' }
            };
            
            const style = colors[type] || colors.info;
            notification.style.backgroundColor = style.bg;
            notification.style.border = `1px solid ${style.border}`;
            notification.style.color = style.color;
            notification.innerHTML = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        function handleFileSelect() {
            const fileInput = document.getElementById('fileInput');
            if (!fileInput.files) return;
            
            selectedFiles = Array.from(fileInput.files);
            
            let previewHtml = '';
            selectedFiles.forEach((file, index) => {
                let icon = 'üìé';
                if (file.type.startsWith('image/')) icon = 'üñºÔ∏è';
                else if (file.type.startsWith('audio/')) icon = 'üéµ';
                else if (file.type.startsWith('video/')) icon = 'üé¨';
                
                previewHtml += `
                    <div class="lxmf-file-tag">
                        <span>${icon} ${escapeHtml(file.name)} (${formatBytes(file.size)})</span>
                        <span class="remove" onclick="removeFile(${index})">‚úï</span>
                    </div>
                `;
            });
            
            document.getElementById('filePreview').innerHTML = previewHtml;
            debugLog('File selezionati', selectedFiles.length);
        }

        function removeFile(index) {
            selectedFiles.splice(index, 1);
            
            if (selectedFiles.length === 0) {
                document.getElementById('filePreview').innerHTML = '';
                document.getElementById('fileInput').value = '';
                return;
            }
            
            let previewHtml = '';
            selectedFiles.forEach((file, i) => {
                let icon = 'üìé';
                if (file.type.startsWith('image/')) icon = 'üñºÔ∏è';
                else if (file.type.startsWith('audio/')) icon = 'üéµ';
                else if (file.type.startsWith('video/')) icon = 'üé¨';
                
                previewHtml += `
                    <div class="lxmf-file-tag">
                        <span>${icon} ${escapeHtml(file.name)} (${formatBytes(file.size)})</span>
                        <span class="remove" onclick="removeFile(${i})">‚úï</span>
                    </div>
                `;
            });
            
            document.getElementById('filePreview').innerHTML = previewHtml;
        }

        // ============================================
        // RENDERING MESSAGGI - CON SUPPORTO RAW ON-DEMAND
        // ============================================
        function renderMessages() {
            if (!currentPeer) {
                document.getElementById('messageList').innerHTML = '<div class="lxmf-no-peer">üëà Seleziona un peer</div>';
                return;
            }
            
            const peerHash = cleanHash(currentPeer.hash);
            const peerMessages = messages.filter(msg => {
                const msgFrom = cleanHash(msg.from || '');
                const msgTo = cleanHash(msg.to || '');
                return msgFrom === peerHash || msgTo === peerHash;
            });
            
            debugLog('Render messages', { total: messages.length, filtered: peerMessages.length, peer: peerHash.substring(0,8) });
            
            if (peerMessages.length === 0) {
                document.getElementById('messageList').innerHTML = '<div class="lxmf-no-messages">üí¨ Nessun messaggio per questo peer</div>';
                return;
            }
            
            const sortedMessages = [...peerMessages].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
            
            let html = '';
            sortedMessages.forEach(msg => {
                const time = new Date(msg.timestamp * 1000).toLocaleTimeString();
                const direction = msg.direction === 'incoming' ? 'incoming' : 'outgoing';
                
                let sender = '';
                if (msg.direction === 'incoming') {
                    const peer = peers.find(p => cleanHash(p.hash) === cleanHash(msg.from));
                    sender = peer ? cleanDisplayName(peer.display_name) : (msg.from ? msg.from.replace(/[<>]/g, '').substring(0,16) + '...' : 'Sconosciuto');
                } else {
                    sender = currentIdentity ? cleanDisplayName(currentIdentity.name) : 'Tu';
                }
                
                let statusIcon = '';
                let retryButton = '';
                
                if (msg.direction === 'outgoing') {
                    if (msg.status === 'delivered') {
                        statusIcon = '<span class="lxmf-message-status delivered" title="Consegnato">‚úì‚úì</span>';
                    } else if (msg.status === 'failed') {
                        statusIcon = '<span class="lxmf-message-status failed" title="Fallito">‚úó</span>';
                        const safeMsg = {
                            content: msg.content || '',
                            timestamp: msg.timestamp,
                            has_attachments: !!(msg.attachments && msg.attachments.length > 0)
                        };
                        retryButton = `<button class="retry-button" onclick="retryMessage(${JSON.stringify(safeMsg).replace(/"/g, '&quot;')})" title="Riprova invio">
                            <span style="font-size: 14px;">‚Üª</span> RIPROVA
                        </button>`;
                    } else if (msg.status === 'sending') {
                        statusIcon = '<span class="lxmf-message-status sending" title="Invio in corso">‚ãØ</span>';
                    }
                }
                
                let radioInfo = '';
                let radioParts = [];
                if (msg.rssi !== undefined && msg.rssi !== null && !isNaN(msg.rssi)) {
                    const rssiClass = getSignalClass(msg.rssi, 'rssi');
                    radioParts.push(`<span class="${rssiClass}">üì∂ RSSI: ${Number(msg.rssi).toFixed(1)}</span>`);
                }
                if (msg.snr !== undefined && msg.snr !== null && !isNaN(msg.snr)) {
                    const snrClass = getSignalClass(msg.snr, 'snr');
                    radioParts.push(`<span class="${snrClass}">üìä SNR: ${Number(msg.snr).toFixed(1)}</span>`);
                }
                if (msg.q !== undefined && msg.q !== null && !isNaN(msg.q)) {
                    radioParts.push(`‚ö° Q: ${Number(msg.q).toFixed(1)}`);
                }
                if (radioParts.length > 0) {
                    radioInfo = `<div class="lxmf-radio-info">${radioParts.join(' ')}</div>`;
                }
                
                let transferInfo = '';
                const isTransfer = msg.total_size && msg.total_size > 0;
                
                if (isTransfer) {
                    const sizeFormatted = formatBytes(msg.total_size);
                    let speedFormatted = (msg.speed && !isNaN(msg.speed)) ? formatSpeed(msg.speed) : '';
                    let elapsedFormatted = (msg.elapsed && !isNaN(msg.elapsed)) ? formatElapsed(msg.elapsed) : '';
                    
                    let statusText = '';
                    let statusClass = '';
                    const progress = (!isNaN(msg.progress)) ? Number(msg.progress) : 0;
                    
                    if (msg.direction === 'incoming') {
                        if (msg.is_receiving) {
                            statusText = progress > 0 ? `üì• Ricezione ${progress.toFixed(1)}%` : 'üì• In attesa...';
                        } else {
                            statusText = 'üì• Ricevuto';
                        }
                        statusClass = 'completed';
                    } else {
                        if (msg.status === 'delivered' || progress >= 100) {
                            statusText = '‚úÖ Inviato';
                            statusClass = 'completed';
                        } else if (msg.status === 'failed') {
                            statusText = '‚ùå Fallito';
                            statusClass = 'failed';
                        } else if (progress > 0) {
                            statusText = `üì§ Invio ${progress.toFixed(1)}%`;
                        } else {
                            statusText = 'üì§ In attesa...';
                        }
                    }
                    
                    let infoParts = [];
                    infoParts.push(`<span class="size">üì¶ ${sizeFormatted}</span>`);
                    if (speedFormatted) infoParts.push(`<span class="speed">‚ö° ${speedFormatted}</span>`);
                    if (elapsedFormatted) infoParts.push(`<span class="time">‚è±Ô∏è ${elapsedFormatted}</span>`);
                    if (msg.parts) infoParts.push(`<span>üìä ${msg.parts}</span>`);
                    
                    transferInfo = `
                        <div class="lxmf-transfer-info">
                            <span class="${statusClass}">${statusText}</span>
                            ${infoParts.join(' ')}
                        </div>
                    `;
                }
                
                let progressBar = '';
                if (isTransfer && msg.progress !== undefined && !isNaN(msg.progress) && msg.progress < 100 && msg.status !== 'delivered') {
                    const progress = Number(msg.progress) || 0;
                    progressBar = `
                        <div class="lxmf-progress-laser" style="margin: 8px 0;">
                            <div class="lxmf-laser-fill" style="width: ${progress}%;"></div>
                            <div class="lxmf-laser-pulse" style="left: ${progress}%;"></div>
                        </div>
                    `;
                }
                
                let mediaPreview = '';
                if (msg.attachments && msg.attachments.length > 0) {
                    msg.attachments.forEach(att => {
                        const filename = att.saved_as ? att.saved_as.split('/').pop() : null;
                        const fileUrl = filename ? `/downloads/${filename}` : null;
                        
                        if (att.type === 'image' && fileUrl) {
                            mediaPreview += `
                                <div class="lxmf-attachment">
                                    <img class="lxmf-image-preview" src="${fileUrl}" 
                                         onclick="openModal('image', this.src)" 
                                         style="max-width: 200px; max-height: 200px; margin-top: 10px; border-radius: 4px; cursor: pointer;">
                                </div>
                            `;
                        } else if (att.type === 'audio' && fileUrl) {
                            mediaPreview += `
                                <div class="lxmf-attachment">
                                    <audio controls style="width: 100%; margin-top: 10px;">
                                        <source src="${fileUrl}">
                                    </audio>
                                </div>
                            `;
                        } else if (att.type === 'file' && fileUrl) {
                            mediaPreview += `
                                <div class="lxmf-attachment">
                                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px; padding: 6px; background: #1a1a1a; border-radius: 4px;">
                                        <span style="font-size: 20px;">üìé</span>
                                        <span style="flex: 1; color: #88ff88;">${escapeHtml(att.name || 'file')}</span>
                                        <span style="color: #888; font-size: 11px;">${formatBytes(att.size || 0)}</span>
                                        <a href="${fileUrl}" download style="color: #88ff88; text-decoration: none; padding: 2px 8px; border: 1px solid #88ff88; border-radius: 4px;">üíæ</a>
                                    </div>
                                </div>
                            `;
                        }
                    });
                }
                
                // RAW VIEW - Carica on-demand
                let rawHtml = '';
                if (rawViewActive && msg.lxmf_file) {
                    const rawId = `raw-${msg.timestamp}-${Date.now()}`;
                    rawHtml = `
                        <div class="lxmf-message-raw" id="${rawId}">
                            <div class="lxmf-message-raw-hex">üì¶ Caricamento dati raw...</div>
                        </div>
                    `;
                    setTimeout(() => loadRawData(msg, peerHash, rawId), 50);
                }
                
                // Usa il formatter per il contenuto
                const contentHtml = formatMessageContent(msg);
                
                html += `
                    <div class="lxmf-message ${direction}">
                        <div class="lxmf-message-sender">${escapeHtml(sender)}</div>
                        ${contentHtml}
                        ${mediaPreview}
                        ${transferInfo}
                        ${progressBar}
                        ${radioInfo}
                        ${rawHtml}
                        <div class="lxmf-message-time">
                            ${time}
                            ${statusIcon}
                            ${retryButton}
                        </div>
                    </div>
                `;
            });
            
            document.getElementById('messageList').innerHTML = html;
            document.getElementById('messageList').scrollTop = document.getElementById('messageList').scrollHeight;
        }

        // Funzione per caricare i dati raw dal file .lxb
        async function loadRawData(msg, peerHash, rawId) {
            if (!msg.lxmf_file) return;
            
            try {
                const response = await fetch(`/api/chat/raw/${peerHash}/${msg.lxmf_file}`);
                const data = await response.json();
                
                if (data.raw_hex) {
                    const rawElement = document.getElementById(rawId);
                    if (rawElement) {
                        rawElement.innerHTML = `
                            <div class="lxmf-message-raw-hex">üì¶ HEX (${data.raw_size || '?'} bytes):<br>${escapeHtml(data.raw_hex.substring(0, 200))}${data.raw_hex.length > 200 ? '...' : ''}</div>
                            <div class="lxmf-message-raw-ascii">üìù ASCII:<br>${escapeHtml(data.raw_ascii ? data.raw_ascii.substring(0, 200) : '')}${data.raw_ascii && data.raw_ascii.length > 200 ? '...' : ''}</div>
                        `;
                    }
                }
            } catch (e) {
                console.error("Errore caricamento raw:", e);
                const rawElement = document.getElementById(rawId);
                if (rawElement) {
                    rawElement.innerHTML = '<div class="lxmf-message-raw-hex">‚ùå Errore caricamento raw</div>';
                }
            }
        }

        // ============================================
        // STATISTICHE TRASFERIMENTO
        // ============================================
        function updateTransferStats() {
            if (activeTransfers.size === 0) {
                document.getElementById('transferStats').innerHTML = '';
                return;
            }
            
            let totalSpeed = 0;
            let activeCount = 0;
            let totalProgress = 0;
            
            activeTransfers.forEach(transfer => {
                if (transfer.speed && !isNaN(transfer.speed)) {
                    totalSpeed += transfer.speed;
                    activeCount++;
                }
                if (transfer.progress && !isNaN(transfer.progress)) {
                    totalProgress += transfer.progress;
                }
            });
            
            if (activeCount > 0) {
                const avgSpeed = totalSpeed / activeCount;
                const avgProgress = totalProgress / activeTransfers.size;
                
                document.getElementById('transferStats').innerHTML = `
                    <div class="lxmf-stats-bar">
                        <span>üì§ Trasferimenti attivi: ${activeTransfers.size}</span>
                        <span>‚ö° Velocit√† media: ${formatSpeed(avgSpeed)}</span>
                        <span>üìä Progresso medio: ${avgProgress.toFixed(1)}%</span>
                    </div>
                `;
            }
        }

        function clearMessages() {
            if (confirm('Cancellare tutti i messaggi di questa chat?')) {
                messages = [];
                renderMessages();
                debugLog('Messaggi cancellati');
            }
        }

        function exportConversation() {
            if (!currentPeer || messages.length === 0) return;
            
            const data = {
                peer: currentPeer,
                identity: currentIdentity,
                messages: messages,
                exported_at: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat_${cleanHash(currentPeer.hash).substring(0,8)}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            debugLog('Conversazione esportata');
        }

        // ============================================
        // MODALE PER ANTEPRIME
        // ============================================
        function openModal(type, src) {
            const modal = document.getElementById('mediaModal');
            const modalImg = document.getElementById('modalImage');
            const modalVideo = document.getElementById('modalVideo');
            
            modalImg.style.display = 'none';
            modalVideo.style.display = 'none';
            modalVideo.pause();
            
            if (type === 'image') {
                modalImg.src = src;
                modalImg.style.display = 'block';
            } else if (type === 'video') {
                modalVideo.src = src;
                modalVideo.style.display = 'block';
                modalVideo.play();
            }
            
            modal.style.display = 'block';
        }

        function closeModal() {
            const modal = document.getElementById('mediaModal');
            const modalVideo = document.getElementById('modalVideo');
            modalVideo.pause();
            modal.style.display = 'none';
        }

        // ============================================
        // FUNZIONE DEBUG IDENTITY
        // ============================================
        function debugIdentity() {
            console.log("üîç DEBUG IDENTITY:", currentIdentity);
            if (currentIdentity) {
                console.log("   name:", currentIdentity.name);
                console.log("   identity_hash:", currentIdentity.identity_hash);
                console.log("   delivery_hash:", currentIdentity.delivery_hash);
                console.log("   address:", currentIdentity.address);
            } else {
                console.log("   currentIdentity √® NULL");
            }
        }

        // ============================================
        // INIZIALIZZAZIONE
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            debugLog('App avviata');
            loadIdentities();
            
            if (Notification.permission !== 'denied') {
                Notification.requestPermission();
            }
            
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'r') {
                    e.preventDefault();
                    refreshPeers();
                }
                if (e.key === 'Escape') {
                    clearSearch();
                }
            });
            
            document.getElementById('peerSearch').addEventListener('input', renderPeerList);
            document.getElementById('messageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            // Debug periodico
            setInterval(() => {
                debugLog('STATO', { 
                    messages: messages.length,
                    currentPeer: currentPeer?.display_name,
                    peerHash: currentPeer ? cleanHash(currentPeer.hash).substring(0,8) : null,
                    cache: Object.fromEntries(messageCache)
                });
            }, 30000);
        });

        window.addEventListener('beforeunload', () => {
            if (peerInterval) clearInterval(peerInterval);
            if (pollInterval) clearInterval(pollInterval);
            if (progressInterval) clearInterval(progressInterval);
        });

        // Esponi funzioni globali
        window.selectPeer = selectPeer;
        window.sendMessage = sendMessage;
        window.toggleRawView = toggleRawView;
        window.toggleMonitor = toggleMonitor;
        window.clearMonitorLog = clearMonitorLog;
        window.handleFileSelect = handleFileSelect;
        window.removeFile = removeFile;
        window.setSortMode = setSortMode;
        window.clearSearch = clearSearch;
        window.clearMessages = clearMessages;
        window.exportConversation = exportConversation;
        window.openModal = openModal;
        window.closeModal = closeModal;
        window.retryMessage = retryMessage;
        window.setMapStyle = setMapStyle;
        window.debugRaw = function() {
            debugLog('DEBUG RAW:', {
                currentPeer: currentPeer?.hash?.substring(0,16),
                incomingPackets: Object.keys(incomingPackets).length,
                packets: currentPeer ? incomingPackets[cleanHash(currentPeer.hash)]?.length : 0
            });
        };
        window.debugIdentity = debugIdentity;
        window.debugTelemetry = function() {
            console.log("üìä DATABASE TELEMETRIA:", telemetryDatabase);
        };
    </script>
</body>
</html>