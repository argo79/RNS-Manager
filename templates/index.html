<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title data-i18n="title">RNID Identity Manager {version}</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="/static/rns_monitor.css">
    <script>
        // Sistema di traduzione multilingua completo
        let translations = {};
        let currentLang = 'it';
        
        // Lista lingue supportate
        const supportedLangs = ['it', 'en', 'fr', 'es', 'de', 'pt', 'ru', 'zh', 'ja', 'ar', 'hi', 'bn', 'ur', 'tr', 'pl'];
        const APP_VERSION = "1.0.3";

        // Determina la lingua del browser all'avvio
        function detectBrowserLanguage() {
            try {
                const browserLang = navigator.language || navigator.userLanguage || 'it';
                const shortLang = browserLang.split('-')[0].toLowerCase();
                return supportedLangs.includes(shortLang) ? shortLang : 'it';
            } catch (e) {
                console.warn('Errore rilevamento lingua:', e);
                return 'it';
            }
        }
        
        // Carica traduzioni
        async function loadTranslations(lang) {
            try {
                const response = await fetch('/static/index_translations.json');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                translations = data[lang] || data.it;
                currentLang = lang;
                
                // Salva preferenza
                localStorage.setItem('rns_language', lang);
                
                // Aggiorna attributo lang
                document.documentElement.lang = lang;
                
                // Aggiorna dropdown
                const selector = document.getElementById('languageSelector');
                if (selector) selector.value = lang;
                
                // Traduci tutto
                translatePage();
                translateDynamicContent();
                
                // Ricarica identitÃ  se presente
                if (typeof loadIdentities === 'function' && document.getElementById('identitiesList').children.length > 1) {
                    loadIdentities();
                }
                
                return true;
            } catch (error) {
                console.error('Errore caricamento traduzioni:', error);
                // Fallback esteso
                translations = getItalianFallback();
                translatePage();
                return false;
            }
        }
        
        // Traduzioni italiane di fallback (COMPLETE)
        function getItalianFallback() {
            return {
                "title": "RNID Identity Manager 1.0.1",
                "subtitle": "Gestione identitÃ  Reticulum",
                "monitor": "ğŸ“¡ APRI MONITOR",
                "identities": "IDENTITÃ€ DISPONIBILI",
                "load": "ğŸ”„ Carica",
                "search": "ğŸ” Cerca",
                "import": "IMPORT",
                "export": "EXPORT",
                "generate": "GENERA",
                "file_identity": "Importa da file (64 bytes):",
                "file_choose": "ğŸ“ Scegli file",
                "optional_name": "Nome identitÃ  (opzionale):",
                "optional_name_placeholder": "es: nodo_remoto, server_backup, ecc.",
                "empty_name_hint": "Se lasciato vuoto, verrÃ  generato automaticamente",
                "or_import_data": "Oppure importa da dati:",
                "import_from_hex": "HEX",
                "import_from_base32": "Base32",
                "import_from_base64": "Base64",
                "paste_data": "Incolla i dati identitÃ  qui...",
                "export_selected": "Esporta identitÃ  selezionata:",
                "new_identity_name": "Nome nuova identitÃ :",
                "new_identity_placeholder": "New_identity",
                "generate_new": "Genera IdentitÃ ",
                "verify_analyze": "VERIFICA & ANALISI HASH",
                "hash_input": "Inserisci hash (32 bytes HEX):",
                "hash_placeholder": "Es: bd96b8a833b14e64d57e781c3e7e4836",
                "identity_name": "Nome identitÃ  (opzionale):",
                "identity_name_placeholder": "Es: remote node",
                "analyze": "ğŸ” Analizza",
                "clear": "ğŸ—‘ Pulisci",
                "add_to_public": "â• Aggiungi alle Pubbliche",
                "aspect_calc": "CALCOLO HASH ASPECT",
                "aspect_input": "Inserisci aspect RNS",
                "calculate": "ğŸ”¢ Calcola",
                "encrypt_decrypt": "ğŸ” CIFRATURA & DECIFRATURA",
                "file_tab": "ğŸ“ File",
                "text_tab": "ğŸ“ Testo",
                "file_input": "File input:",
                "file_output": "File output:",
                "output_placeholder": "es: output.txt.enc o output.txt",
                "encrypt_file": "ğŸ”’ Cifra File",
                "decrypt_file": "ğŸ”“ Decifra File",
                "text_to_crypto": "Testo da cifrare/decifrare:",
                "paste_text": "Incolla il testo qui...",
                "encrypt_text": "ğŸ”’ Cifra Testo",
                "decrypt_text": "ğŸ”“ Decifra Testo",
                "clear_text": "ğŸ—‘ Pulisci",
                "encrypted_text": "Testo cifrato:",
                "decrypted_text": "Testo decifrato:",
                "copy": "ğŸ“‹ Copia",
                "sign_verify": "âœï¸ FIRMA & VERIFICA FIRMA",
                "file_to_sign": "File da firmare/verificare:",
                "signature_file": "File firma .rsg (solo per verifica):",
                "signature_output": "File firma output (.rsg):",
                "signature_placeholder": "es: documento.rsg",
                "sign_file": "âœï¸ Firma File",
                "verify_signature": "âœ… Verifica Firma",
                "verify_result": "Risultato verifica:",
                "identity_info": "INFORMAZIONI IDENTITÃ€",
                "info_identity": "â„¹ Info IdentitÃ ",
                "announce_identity": "ğŸ“¢ Annuncia",
                "announce_aspect": "Aspect da annunciare",
                "announce_custom": "ğŸ“¢ Annuncia Custom",
                "rnid_commands": "COMANDI RNID",
                "execute": "â–¶ Esegui",
                "clear_command": "ğŸ—‘ Pulisci",
                "output": "OUTPUT",
                "info": "INFORMAZIONI",
                "supported_formats": "Formati supportati:",
                "hex_format": "<strong>HEX</strong>: 128 caratteri",
                "base32_format": "<strong>BASE32</strong>: maiuscolo, con '='",
                "base64_format": "<strong>BASE64</strong>: standard, con '=='",
                "aspects_list": "<strong>Aspects RNS:</strong> rnstransport.probe, lxmf.delivery, nomadnetwork.node, lxmf.propagation, call.audio, lxst.telephony",
                "warning_load": " Premi \"Carica\" per visualizzare le identitÃ ",
                "loading": "Caricamento...",
                "no_identities": "Nessuna identitÃ  trovata",
                "select_identity_first": "âŒ Seleziona prima un'identitÃ !",
                "select_file_first": "âŒ Seleziona prima un file!",
                "select_sig_file_first": "âŒ Seleziona prima il file firma .rsg!",
                "paste_data_first": "âŒ Incolla i dati identitÃ  prima!",
                "enter_aspect": "âŒ Inserisci un aspect!",
                "enter_text": "âŒ Inserisci del testo da cifrare!",
                "enter_hash": "âŒ Inserisci un hash da verificare!",
                "invalid_hash": "âŒ Hash deve essere 32 o 64 caratteri esadecimali.",
                "private_identity_needed": "âŒ Per DECIFRARE/FIRMARE serve un'identitÃ  PRIVATA",
                "public_only": "âŒ pubblica",
                "operation_completed": "âœ… Operazione completata",
                "copy_success": "âœ… Copiato!",
                "copy_error": "âŒ Errore nella copia",
                "error": "âŒ Errore",
                "success": "âœ… Successo",
                "warning": "âš  Attenzione",
                "exporting": "Esportazione in {format}...",
                "export_success": "âœ… Esportazione {format} completata",
                "importing": "Importazione {format}...",
                "import_success": "âœ… Importazione completata",
                "generating": "Generazione \"{name}\"...",
                "generate_success": "âœ… Generazione completata",
                "verifying": "Analisi hash: {hash}",
                "verify_success": "âœ… Analisi completata per: {hash}",
                "encrypting": "ğŸ”’ Cifratura in corso...",
                "decrypting": "ğŸ”“ Decifratura in corso...",
                "signing": "âœï¸ Firma file: {name}...",
                "sign_success": "âœ… Firma completata",
                "valid_signature": "âœ… FIRMA VALIDA",
                "invalid_signature": "âŒ FIRMA NON VALIDA",
                "scanning": "ğŸ” Scansione storage...",
                "scan_complete": "âœ… Scansione completata",
                "extracting_hash": "ğŸ” Estrazione hash RNS pubblico...",
                "hash_found": "âœ… Hash RNS pubblico: {hash}",
                "command_ready": "âœ… Comando pronto:\n{command}\n\nFile verrÃ  salvato in: {path}",
                "upload_encrypt": "ğŸ”’ Upload e cifratura file...",
                "upload_decrypt": "ğŸ”“ Upload e decifratura file...",
                "file_selected": "âœ… File selezionato: {name} ({size} bytes)",
                "sig_file_selected": "âœ… File firma selezionato: {name}",
                "no_data_to_copy": "âŒ Nessun dato da copiare",
                "copy_error_details": "âŒ Errore nella copia: {error}",
                "cleanup_text": "ğŸ—‘ Testo e risultati crittografia puliti",
                "public_identity_removed": "âœ… IdentitÃ  pubblica rimossa",
                "public_identity_added": "âœ… IdentitÃ  pubblica \"{name}\" aggiunta!",
                "public_identity_exists": "âš  IdentitÃ  pubblica giÃ  presente come \"{name}\"",
                "confirm_remove_public": "Sei sicuro di voler rimuovere questa identitÃ  pubblica?",
                "selected_public": "âœ… Selezionata identitÃ  pubblica: {hash}",
                "selected_private": "âœ… Selezionata: {name}",
                "identity_imported": "âœ… IdentitÃ  importata!\nNome: {name}\nRNS: {hash}...",
                "identity_generated": "âœ… Generata: {path}\n{info}",
                "command_executing": "Esecuzione: {command}",
                "command_completed": "âœ… Completato\n\n{output}",
                "command_error": "âŒ Errore (code: {code})\n{error}\n{output}",
                "aspect_rilevato": "âœ… ASPECT HASH RILEVATO (64 chars)",
                "aspect_hash_originale": "<strong>Aspect hash originale (64 chars):</strong> <code style=\"color:#0ff\">{hash}</code>",
                "rns_hash_corrispondente": "<strong>RNS Hash corrispondente (32 chars):</strong> <code style=\"color:#0ff\">{hash}</code>",
                "rns_hash_identita": "âœ… RNS HASH (IDENTITÃ€ PUBBLICA - 32 chars)",
                "rns_hash_value": "<strong>RNS Hash (32 chars):</strong> <code style=\"color:#0ff\">{hash}</code>",
                "hash_riconosciuto": "<em>Hash riconosciuto come identitÃ  RNS pubblica</em>",
                "hash_non_riconosciuto": "âŒ HASH NON RICONOSCIUTO",
                "hash_analisi": "<div>L'hash <code>{hash}</code> ({length} chars) non Ã¨ stato riconosciuto come:</div>",
                "aspect_list_item": "<li>Aspect hash (64 caratteri hex)</li>",
                "rns_list_item": "<li>RNS hash (32 caratteri hex)</li>",
                "error_verifica": "âŒ ERRORE NELLA VERIFICA",
                "error_sconosciuto": "Errore sconosciuto",
                "aspects_calcolati": "<strong>ASPECTS HASH CALCOLATI:</strong>",
                "aspect_calc_error": "{aspect}: Errore nel calcolo",
                "aspect_originale": "â† ORIGINALE",
                "enter_command": "âŒ Inserisci un comando!",
                "enter_output_filename": "âŒ Inserisci un nome per il file output!"
            };
        }
        
        function t(key, params = {}) {
            if (!translations[key]) {
                console.warn(`Traduzione mancante: ${key}`);
                return key;
            }
            
            let text = translations[key];
            
            // Sostituisci i parametri passati
            Object.keys(params).forEach(param => {
                const regex = new RegExp(`\\{${param}\\}`, 'g');
                text = text.replace(regex, params[param]);
            });
            
            // Sostituisci automaticamente {version} con APP_VERSION
            text = text.replace(/\{version\}/g, APP_VERSION);
            
            return text;
        }
        
        function translatePage() {
            // Titolo pagina
            document.title = t('title');
            
            // Elementi con data-i18n
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    el.placeholder = t(key);
                } else if (el.tagName === 'BUTTON' && el.classList.contains('copy-btn')) {
                    // Mantieni icone
                    const icon = el.innerHTML.match(/[ğŸ“‹ğŸ”’ğŸ”“âœï¸âœ…ğŸ”ğŸ”„ğŸ—‘â„¹ğŸ“¢â–¶]/)?.[0] || '';
                    el.innerHTML = icon + ' ' + t(key);
                } else {
                    el.textContent = t(key);
                }
            });
            
            // Placeholder
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                el.placeholder = t(key);
            });
            
            // Valori di default
            document.querySelectorAll('[data-i18n-value]').forEach(el => {
                const key = el.getAttribute('data-i18n-value');
                if (!el.value || el.value === 'New_identity') {
                    el.value = t(key);
                }
            });
            // Per gli elementi che contengono HTML (come le info)
            document.querySelectorAll('[data-i18n-html]').forEach(el => {
                const key = el.getAttribute('data-i18n-html');
                el.innerHTML = t(key); // usa innerHTML invece di textContent
            });
        }
        
        function translateDynamicContent() {
            // Traduci messaggi nella lista identitÃ 
            const list = document.getElementById('identitiesList');
            if (list) {
                const warningDiv = list.querySelector('.warning');
                if (warningDiv && (warningDiv.textContent.includes('Premi "Carica"') || warningDiv.textContent.includes('Press "Load"'))) {
                    warningDiv.textContent = t('warning_load');
                }
            }
            
            // Traduci badge delle identitÃ 
            document.querySelectorAll('.identity-badge').forEach(badge => {
                if (badge.textContent.includes('PUBBLICA') || badge.textContent.includes('PUBLIC')) {
                    badge.textContent = t('public_only');
                }
            });
        }
        
        async function changeLanguage(lang) {
            await loadTranslations(lang);
            
            // Ricarica identitÃ  per aggiornare badge
            if (typeof loadIdentities === 'function') {
                loadIdentities();
            }
            
            // Aggiorna comando corrente se necessario
            const cmdInput = document.getElementById('commandInput');
            if (cmdInput && cmdInput.value.includes('rnid')) {
                // Non tradurre comandi
            }
        }
        
        // Override showOutput
        const originalShowOutput = window.showOutput;
        window.showOutput = function(message, type = '') {
            if (typeof message === 'string' && message.startsWith('_')) {
                const key = message.substring(1);
                message = t(key);
            }
            originalShowOutput(message, type);
        };
        
        // Inizializzazione all'avvio
        window.addEventListener('DOMContentLoaded', async function() {
            // Determina lingua: localStorage > browser > italiano
            const savedLang = localStorage.getItem('rns_language');
            const browserLang = detectBrowserLanguage();
            const initialLang = savedLang || browserLang || 'it';
            
            // Carica traduzioni
            await loadTranslations(initialLang);
            
            // Inizializza comando
            document.getElementById('commandInput').value = 'rnid -h';
            setTimeout(() => {
                if (typeof executeCommand === 'function') {
                    executeCommand();
                }
            }, 500);
            
            // Messaggio lista identitÃ 
            const list = document.getElementById('identitiesList');
            if (list) {
                list.innerHTML = `<div class="warning">${t('warning_load')}</div>`;
            }
        });
    </script>
</head>
<body class="id-mgr">
    <div class="container">
        <header>
            <div class="header-title">
                <h1 data-i18n="title">RETICULUM IDENTITY MANAGER 1.0.2</h1>
                <div class="header-subtitle" data-i18n="subtitle">Gestione identitÃ  Reticulum</div>
            </div>
            <div style="display: flex; gap: 8px; align-items: center;">
                <select id="languageSelector" onchange="changeLanguage(this.value)" 
                        style="background: #222; color: #0f0; border: 1px solid #333; padding: 8px; border-radius: 3px; font-family: inherit; font-size: 12px; cursor: pointer;">
                    <option value="it">ğŸ‡®ğŸ‡¹ Italiano</option>
                    <option value="en">ğŸ‡¬ğŸ‡§ English</option>
                    <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
                    <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
                    <option value="de">ğŸ‡©ğŸ‡ª Deutsch</option>
                    <option value="pt">ğŸ‡µğŸ‡¹ PortuguÃªs</option>
                    <option value="ru">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                    <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
                    <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª</option>
                    <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                    <option value="hi">ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
                    <option value="bn">ğŸ‡§ğŸ‡© à¦¬à¦¾à¦‚à¦²à¦¾</option>
                    <option value="ur">ğŸ‡µğŸ‡° Ø§Ø±Ø¯Ùˆ</option>
                    <option value="tr">ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e</option>
                    <option value="pl">ğŸ‡µğŸ‡± Polski</option>
                </select>
                <a href="/monitor" class="monitor-button" data-i18n="monitor">ğŸ“¡ APRI MONITOR</a>
            </div>
        </header>
        
        <div class="row">
            <!-- COLONNA 1: Gestione IdentitÃ  -->
            <div class="col">
                <div class="section">
                    <h2 data-i18n="identities">IDENTITÃ€ DISPONIBILI</h2>
                    <div class="button-group">
                        <button onclick="loadIdentities()" data-i18n="load">ğŸ”„ Carica</button>
                        <button class="secondary" onclick="scanAllStorage()" data-i18n="search">ğŸ” Cerca</button>
                    </div>
                    
                    <div id="identitiesList" class="identities-list">
                        <div class="warning" data-i18n="warning_load"> Premi "Carica" per visualizzare le identitÃ </div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="tabs">
                        <div class="tab active" onclick="showTab('import-tab')" data-i18n="import">IMPORT</div>
                        <div class="tab" onclick="showTab('export-tab')" data-i18n="export">EXPORT</div>
                        <div class="tab" onclick="showTab('generate-tab')" data-i18n="generate">GENERA</div>
                    </div>
                    
                    <!-- IMPORT TAB -->
                    <div id="import-tab" class="tab-content active">
                        <div class="form-group">
                            <label data-i18n="file_identity">Importa da file (64 bytes):</label>
                            <div class="file-input-wrapper">
                                <button data-i18n="file_choose">ğŸ“ Scegli file identitÃ </button>
                                <input type="file" id="fileImport" accept="*" onchange="handleFileImport()">
                            </div>
                            <div class="form-group" style="margin-top: 8px;">
                                <label data-i18n="optional_name">Nome identitÃ  (opzionale):</label>
                                <input type="text" id="importFileName" 
                                       data-i18n-placeholder="optional_name_placeholder"
                                       placeholder="es: nodo_remoto, server_backup, ecc."
                                       style="font-family: inherit; font-size: 11px; width: 100%;">
                                <div style="font-size: 10px; color: #888; margin-top: 2px;" data-i18n="empty_name_hint">
                                    Se lasciato vuoto, verrÃ  generato automaticamente
                                </div>
                            </div>
                            <div id="fileImportStatus" style="font-size:10px; margin-top:4px;"></div>
                        </div>
                        
                        <div class="form-group">
                            <label data-i18n="or_import_data">Oppure importa da dati:</label>
                            <div class="button-group">
                                <button class="secondary" onclick="importFromData('hex')" data-i18n="import_from_hex">HEX</button>
                                <button class="secondary" onclick="importFromData('base32')" data-i18n="import_from_base32">Base32</button>
                                <button class="secondary" onclick="importFromData('base64')" data-i18n="import_from_base64">Base64</button>
                            </div>
                            <div class="form-group" style="margin-top: 8px;">
                                <label data-i18n="optional_name">Nome identitÃ  (opzionale):</label>
                                <input type="text" id="importDataName" 
                                       data-i18n-placeholder="optional_name_placeholder"
                                       placeholder="es: nodo_remoto, server_backup, ecc."
                                       style="font-family: inherit; font-size: 11px; width: 100%;">
                            </div>
                            <textarea id="importData" data-i18n-placeholder="paste_data" placeholder="Incolla i dati identitÃ  qui..."></textarea>
                        </div>
                    </div>

                    <!-- EXPORT TAB -->
                    <div id="export-tab" class="tab-content">
                        <div class="form-group">
                            <label data-i18n="export_selected">Esporta identitÃ  selezionata:</label>
                            <div class="button-group">
                                <button onclick="exportIdentity('hex')" data-i18n="import_from_hex">HEX</button>
                                <button onclick="exportIdentity('base32')" data-i18n="import_from_base32">Base32</button>
                                <button onclick="exportIdentity('base64')" data-i18n="import_from_base64">Base64</button>
                            </div>
                            <div id="exportResult" style="margin-top:8px;"></div>
                        </div>
                    </div>
                    
                    <!-- GENERATE TAB -->
                    <div id="generate-tab" class="tab-content">
                        <div class="form-group">
                            <label data-i18n="new_identity_name">Nome nuova identitÃ :</label>
                            <input type="text" id="newIdentityName" data-i18n-value="new_identity_placeholder" value="New_identity">
                            <button onclick="generateNewIdentity()" data-i18n="generate_new">Genera IdentitÃ </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- COLONNA 2: Operazioni & Analytics -->
            <div class="col">                
                <div class="section">
                    <h2 data-i18n="verify_analyze">VERIFICA & ANALISI HASH</h2>
                    <div class="form-group">
                        <label data-i18n="hash_input">Inserisci hash (32 bytes HEX):</label>
                        <input type="text" id="verifyHashInput" 
                               data-i18n-placeholder="hash_placeholder"
                               placeholder="Es: bd96b8a833b14e64d57e781c3e7e4836"
                               style="font-family: monospace; font-size: 11px; width: 100%;">
                        
                        <label style="margin-top: 8px;" data-i18n="identity_name">Nome identitÃ  (opzionale):</label>
                        <input type="text" id="publicIdentityName" 
                               data-i18n-placeholder="identity_name_placeholder"
                               placeholder="Es: remote node"
                               style="font-family: inherit; font-size: 11px; width: 100%;">
                        
                        <div class="button-group">
                            <button onclick="verifyHash()" data-i18n="analyze">ğŸ” Analizza</button>
                            <button class="secondary" onclick="clearVerify()" data-i18n="clear">ğŸ—‘ Pulisci</button>
                            <button class="secondary" onclick="addToPublicIdentities()" id="addToIdentitiesBtn" style="display:none;" data-i18n="add_to_public">â• Aggiungi alle Pubbliche</button>
                        </div>
                    </div>
                    
                    <div id="verifyResult" style="margin-top: 10px; font-size: 11px; max-height: 300px; overflow-y: auto; padding: 8px; background: #111; border: 1px solid #333; border-radius: 3px;"></div>
                </div>

                <div class="section">
                    <h2 data-i18n="aspect_calc">CALCOLO HASH ASPECT</h2>
                    <div class="aspect-input-group">
                        <input type="text" id="aspectInput" data-i18n-placeholder="aspect_input" value="rnstransport.probe">
                        <button onclick="calculateAspectHash()" data-i18n="calculate">ğŸ”¢ Calcola</button>
                    </div>
                    
                    <div class="aspect-buttons">
                        <button class="aspect-btn" onclick="setAspect('rnstransport.probe')">rnstransport.probe</button>
                        <button class="aspect-btn" onclick="setAspect('lxmf.delivery')">lxmf.delivery</button>
                        <button class="aspect-btn" onclick="setAspect('nomadnetwork.node')">nomadnetwork.node</button>
                        <button class="aspect-btn" onclick="setAspect('lxmf.propagation')">lxmf.propagation</button>
                        <button class="aspect-btn" onclick="setAspect('call.audio')">call.audio</button>
                        <button class="aspect-btn" onclick="setAspect('lxst.telephony')">lxst.telephony</button>
                    </div>
                </div>

                <!-- SEZIONE CIFRATURA & DECIFRATURA -->
                <div class="section">
                    <h2 data-i18n="encrypt_decrypt">ğŸ” CIFRATURA & DECIFRATURA</h2>
                    
                    <div class="tabs" id="crypto-tabs">
                        <div class="tab active" onclick="showCryptoTab('crypto-file-tab')" data-i18n="file_tab">ğŸ“ File</div>
                        <div class="tab" onclick="showCryptoTab('crypto-text-tab')" data-i18n="text_tab">ğŸ“ Testo</div>
                    </div>
                    
                    <!-- TAB FILE -->
                    <div id="crypto-file-tab" class="tab-content active">
                        <div class="form-group">
                            <label data-i18n="file_input">File input:</label>
                            <div class="file-input-wrapper">
                                <button data-i18n="file_choose">ğŸ“ Scegli file</button>
                                <input type="file" id="cryptoFileInput" accept="*" onchange="handleCryptoFileSelect()">
                            </div>
                            <div id="cryptoFileStatus" style="font-size:10px; margin-top:4px;"></div>
                        </div>
                        
                        <div class="form-group">
                            <label data-i18n="file_output">File output:</label>
                            <input type="text" id="outputFileName" 
                                   data-i18n-placeholder="output_placeholder"
                                   placeholder="es: output.txt.enc o output.txt"
                                   style="font-family: monospace; font-size: 11px;">
                        </div>
                        
                        <div class="button-group">
                            <button onclick="encryptFile()" data-i18n="encrypt_file">ğŸ”’ Cifra File</button>
                            <button onclick="decryptFile()" data-i18n="decrypt_file">ğŸ”“ Decifra File</button>
                        </div>
                    </div>
                    
                    <!-- TAB TESTO -->
                    <div id="crypto-text-tab" class="tab-content">
                        <div class="form-group">
                            <label data-i18n="text_to_crypto">Testo da cifrare/decifrare:</label>
                            <textarea id="cryptoTextInput" 
                                     data-i18n-placeholder="paste_text"
                                     placeholder="Incolla il testo qui..."
                                     style="height: 80px; font-family: monospace; font-size: 11px;"></textarea>
                        </div>
                        
                        <div class="button-group">
                            <button onclick="encryptText()" data-i18n="encrypt_text">ğŸ”’ Cifra Testo</button>
                            <button onclick="decryptText()" data-i18n="decrypt_text">ğŸ”“ Decifra Testo</button>
                            <button class="secondary" onclick="clearCryptoText()" data-i18n="clear_text">ğŸ—‘ Pulisci</button>
                        </div>
                        
                        <!-- RISULTATO CIFRATO -->
                        <div id="cryptoEncryptedResult" style="margin-top: 10px; display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <label style="margin: 0; font-size: 11px;" data-i18n="encrypted_text">Testo cifrato:</label>
                                <button class="crypto-copy-btn" onclick="copyEncryptedResult()" data-i18n="copy">
                                    ğŸ“‹ Copia
                                </button>
                            </div>
                            <textarea id="cryptoEncryptedOutput" 
                                     readonly
                                     style="width:100%; height: 60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                     onclick="this.select()"></textarea>
                        </div>
                        
                        <!-- RISULTATO DECIFRATO -->
                        <div id="cryptoDecryptedResult" style="margin-top: 10px; display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <label style="margin: 0; font-size: 11px;" data-i18n="decrypted_text">Testo decifrato:</label>
                                <button class="crypto-copy-btn" onclick="copyDecryptedResult()" data-i18n="copy">
                                    ğŸ“‹ Copia
                                </button>
                            </div>
                            <textarea id="cryptoDecryptedOutput" 
                                     readonly
                                     style="width:100%; height: 60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                     onclick="this.select()"></textarea>
                        </div>
                    </div>
                </div>

                <!-- SEZIONE FIRMA & VERIFICA FIRMA -->
                <div class="section">
                    <h2 data-i18n="sign_verify">âœï¸ FIRMA & VERIFICA FIRMA</h2>
                    
                    <div class="form-group">
                        <label data-i18n="file_to_sign">File da firmare/verificare:</label>
                        <div class="file-input-wrapper">
                            <button data-i18n="file_choose">ğŸ“ Scegli file</button>
                            <input type="file" id="signFileInput" accept="*" onchange="handleSignFileSelect()">
                        </div>
                        <div id="signFileStatus" style="font-size:10px; margin-top:4px;"></div>
                    </div>
                    
                    <div class="form-group">
                        <label data-i18n="signature_file">File firma .rsg (solo per verifica):</label>
                        <div class="file-input-wrapper">
                            <button data-i18n="file_choose">ğŸ“ Scegli file .rsg</button>
                            <input type="file" id="sigFileInput" accept=".rsg" onchange="handleSigFileSelect()">
                        </div>
                        <div id="sigFileStatus" style="font-size:10px; margin-top:4px;"></div>
                    </div>
                    
                    <div class="form-group">
                        <label data-i18n="signature_output">File firma output (.rsg):</label>
                        <input type="text" id="signatureFileName" 
                               data-i18n-placeholder="signature_placeholder"
                               placeholder="es: documento.rsg"
                               style="font-family: monospace; font-size: 11px; width: 100%;"
                               value="">
                    </div>
                    
                    <div class="button-group">
                        <button onclick="signFile()" data-i18n="sign_file">âœï¸ Firma File</button>
                        <button onclick="verifySignature()" data-i18n="verify_signature">âœ… Verifica Firma</button>
                    </div>
                    
                    <!-- RISULTATO VERIFICA -->
                    <div id="verifyResultSection" style="margin-top: 10px; display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <label style="margin: 0; font-size: 11px;" data-i18n="verify_result">Risultato verifica:</label>
                            <button class="crypto-copy-btn" onclick="copyVerifyResult()" data-i18n="copy">
                                ğŸ“‹ Copia
                            </button>
                        </div>
                        <textarea id="verifyResultOutput" 
                                 readonly
                                 style="width:100%; height: 80px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                 onclick="this.select()"></textarea>
                    </div>
                </div>
            </div>
            
            <!-- COLONNA 3: Interazione & Output -->
            <div class="col">
                <div class="section">
                    <h2 data-i18n="identity_info">INFORMAZIONI IDENTITÃ€</h2>
                    <div class="button-group">
                        <button class="secondary" onclick="showIdentityInfo()" data-i18n="info_identity">â„¹ Info IdentitÃ </button>
                        <button class="secondary" onclick="announceWithAspect()" data-i18n="announce_identity">ğŸ“¢ Annuncia</button>
                    </div>
                    
                    <div class="aspect-input-group" style="margin-top: 10px;">
                        <input type="text" id="announceAspect" data-i18n-placeholder="announce_aspect" value="rnstransport.probe">
                        <button class="secondary" onclick="announceWithCustomAspect()" data-i18n="announce_custom">ğŸ“¢ Annuncia Custom</button>
                    </div>
                </div>
                
                <!-- SEZIONE COMANDI RNID -->
                <div class="section">
                    <h2 data-i18n="rnid_commands">COMANDI RNID</h2>
                    <div class="command-area">
                        <textarea id="commandInput">rnid -h</textarea>
                        <div class="button-group">
                            <button onclick="executeCommand()" data-i18n="execute">â–¶ Esegui</button>
                            <button class="secondary" onclick="clearCommand()" data-i18n="clear_command">ğŸ—‘ Pulisci</button>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2 data-i18n="output">OUTPUT</h2>
                    <div id="output" class="output"></div>
                </div>
                
                <div class="section">
                    <h2 data-i18n="info">INFORMAZIONI</h2>
                    <div style="font-size: 11px; color: #888; line-height: 1.3;">
                        <div style="margin-bottom: 5px;" data-i18n="supported_formats">
                            <strong>Formati supportati:</strong>
                        </div>
                        <div style="margin-bottom: 3px;" data-i18n-html="hex_format"><strong>HEX</strong>: 128 caratteri</div>
                        <div style="margin-bottom: 3px;" data-i18n-html="base32_format"><strong>BASE32</strong>: maiuscolo, con '='</div>
                        <div style="margin-bottom: 3px;" data-i18n-html="base64_format"><strong>BASE64</strong>: standard, con '=='</div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333;" data-i18n-html="aspects_list">
                            <strong>Aspects RNS:</strong> rnstransport.probe, lxmf.delivery, nomadnetwork.node, lxmf.propagation, call.audio, lxst.telephony
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===========================================
        // TUTTO IL CODICE ORIGINALE QUI (COMPLETO)
        // ===========================================
        
        let selectedIdentity = null;
        let lastExportedData = null;
        let selectedSigFileForVerification = null;
        let selectedCryptoFile = null;
        let selectedSignFile = null;
        let currentVerification = {
            originalHash: null,
            rnsHash: null,
            type: null,
            aspects: {},
            isPublic: true
        };

        // Tab management
        function showTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }
        
        function showCryptoTab(tabId) {
            document.querySelectorAll('#crypto-tabs .tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('#crypto-tabs ~ .tab-content, #crypto-tabs + .tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }
        
        function setAspect(aspect) {
            document.getElementById('aspectInput').value = aspect;
            document.getElementById('announceAspect').value = aspect;
            if (selectedIdentity) {
                if (selectedIdentity.startsWith('public:')) {
                    const rnsHash = selectedIdentity.replace('public:', '');
                    document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -H "${aspect}"`;
                } else {
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    document.getElementById('commandInput').value = `rnid -i ${cmdPath} -H "${aspect}"`;
                }
            }
        }
        
        async function loadIdentities() {
            const list = document.getElementById('identitiesList');
            list.innerHTML = `<div class="warning">${t('loading')}</div>`;
            
            try {
                const response = await fetch('/api/identities/list');
                const backendData = await response.json();
                const backendIdentities = backendData.identities || [];
                
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                
                if (backendIdentities.length === 0 && publicIdentities.length === 0) {
                    list.innerHTML = `<div class="warning">${t('no_identities')}</div>`;
                    return;
                }
                
                let html = '';
                
                backendIdentities.forEach(identity => {
                    html += renderIdentityItem(identity, false);
                });
                
                publicIdentities.forEach(identity => {
                    identity.isPublic = true;
                    html += renderIdentityItem(identity, true);
                });
                
                list.innerHTML = html;
                translateDynamicContent();
                
            } catch (error) {
                console.error('Errore loadIdentities:', error);
                list.innerHTML = `<div class="error">${t('error')}: ${error}</div>`;
            }
        }

        function renderIdentityItem(identity, isPublic = false) {
            const validClass = isPublic ? 'success' : (identity.valid ? 'success' : 'warning');
            
            let sizeInfo = '';
            if (identity.size) {
                sizeInfo = identity.size === 64 ? '64 bytes âœ“' : `${identity.size} bytes`;
            } else {
                sizeInfo = isPublic ? '32 bytes (pubblica)' : '? bytes';
            }
            
            const name = identity.name || (isPublic ? `public_${identity.rns_hash?.substring(0, 8)}` : 'unknown');
            const app = identity.app || (isPublic ? 'public' : 'unknown');
            
            let hashInfo = '';
            const rnsHash = identity.rns_hash || identity.rnsHash;
            if (rnsHash) {
                const shortHash = rnsHash.length > 32 ? rnsHash.substring(0, 32) + '...' : rnsHash;
                hashInfo = `<div style="font-size: 10px; color: #0ff; font-family: monospace; margin-top: 2px;">RNS: ${shortHash}</div>`;
            }
            
            let aspectInfo = '';
            const rnsAspects = ['rnstransport.probe', 'lxmf.delivery', 'nomadnetwork.node', 'lxmf.propagation', 'call.audio', 'lxst.telephony'];
            const aspectHashes = identity.aspect_hashes || identity.aspects || {};
            
            rnsAspects.forEach(aspect => {
                if (aspectHashes[aspect]) {
                    const hash = aspectHashes[aspect];
                    const shortHash = hash.length > 32 ? hash.substring(0, 32) + '...' : hash;
                    aspectInfo += `<div style="font-size: 9px; color: ${isPublic ? '#8f8' : '#888'}; margin-top: 1px;">${aspect.split('.').pop()}: ${shortHash}</div>`;
                }
            });
            
            let deleteButton = '';
            if (isPublic && rnsHash) {
                deleteButton = `<button onclick="event.stopPropagation(); removePublicIdentity('${rnsHash}')" style="background: #f44; color: white; border: none; padding: 2px 5px; font-size: 9px; border-radius: 2px; margin-left: 5px; cursor: pointer; vertical-align: middle;">âœ•</button>`;
            }
            
            return `
                <div class="identity-item" onclick="${isPublic ? `selectPublicIdentity('${rnsHash}', this)` : `selectIdentity('${identity.path}', this)`}">
                    <div style="flex: 1;">
                        <div class="identity-name">${name} ${isPublic ? 'ğŸŒ' : 'ğŸ”‘'} ${deleteButton}</div>
                        <div class="identity-info">${sizeInfo} â€¢ ${app} ${hashInfo} ${aspectInfo}</div>
                    </div>
                    <span class="identity-badge ${validClass}">${isPublic ? t('public_only') : (identity.valid ? t('private_badge') : t('verify_badge'))}</span>
                </div>
            `;
        }

        function removePublicIdentity(rnsHash) {
            if (!confirm(t('confirm_remove_public'))) return;
            
            try {
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                const filteredIdentities = publicIdentities.filter(id => id.rns_hash !== rnsHash);
                localStorage.setItem('rns_public_identities', JSON.stringify(filteredIdentities));
                showOutput(t('public_identity_removed'), 'success');
                loadIdentities();
            } catch (error) {
                showOutput(t('error') + ': ' + error, 'error');
            }
        }

        function selectPublicIdentity(rnsHash, element) {
            document.querySelectorAll('.identity-item').forEach(item => item.classList.remove('selected'));
            element.classList.add('selected');
            selectedIdentity = `public:${rnsHash}`;
            document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" --print-identity`;
            showOutput(t('selected_public', { hash: rnsHash }), 'success');
        }
        
        function selectIdentity(path, element) {
            document.querySelectorAll('.identity-item').forEach(item => item.classList.remove('selected'));
            element.classList.add('selected');
            selectedIdentity = path;
            const hasSpaces = path.includes(' ');
            const cmdPath = hasSpaces ? `"${path}"` : path;
            document.getElementById('commandInput').value = `rnid -i ${cmdPath} --print-identity -P`;
            showOutput(t('selected_private', { name: path.split('/').pop() }), 'success');
        }
        
        async function exportIdentity(format) {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            showOutput(t('exporting', { format: format.toUpperCase() }), 'warning');
            
            try {
                const response = await fetch('/api/identities/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: selectedIdentity, format })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    lastExportedData = { format: format, data: data.data };
                    
                    const output = document.getElementById('exportResult');
                    output.innerHTML = `
                        <div style="margin-bottom: 8px;"><span class="success">${t('export_success', { format: format.toUpperCase() })}</span></div>
                        <div class="export-buttons"><button class="copy-btn" onclick="copyExportedData()">${t('copy')} ${format.toUpperCase()}</button></div>
                        <textarea id="exportedData" readonly style="width:100%; height:60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: vertical;">${data.data}</textarea>
                        <div style="margin-top:8px; font-size:10px; color:#888;">Lunghezza: ${data.length} caratteri</div>
                    `;
                    
                    showOutput(t('export_success', { format: format.toUpperCase() }), 'success');
                } else {
                    showOutput(t('error') + ': ' + data.error, 'error');
                }
            } catch (error) {
                showOutput(t('error') + ': ' + error, 'error');
            }
        }
        
        function copyExportedData() {
            const textarea = document.getElementById('exportedData');
            if (!textarea || !textarea.value) {
                showOutput('_no_data_to_copy', 'error');
                return;
            }
            
            let textToCopy = textarea.value.trim();
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                showOutput('_copy_success', 'success');
            }).catch(err => {
                textarea.select();
                document.execCommand('copy');
                showOutput('_copy_success', 'success');
            });
        }
        
        async function handleFileImport() {
            const fileInput = document.getElementById('fileImport');
            const file = fileInput.files[0];
            const status = document.getElementById('fileImportStatus');
            const nameInput = document.getElementById('importFileName');
            
            if (!file) {
                showOutput('_select_file_first', 'error');
                return;
            }
            
            let suggestedName = nameInput.value.trim();
            if (!suggestedName) {
                const timestamp = new Date().getTime().toString().slice(-6);
                suggestedName = `imported_${timestamp}`;
            }
            
            status.innerHTML = t('importing', { format: 'file' });
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('suggested_name', suggestedName);
            
            try {
                const response = await fetch('/api/identities/import/file', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const importedName = data.name || suggestedName;
                    const rnsHash = data.rns_hash || 'N/D';
                    const shortHash = rnsHash.substring(0, 8);
                    
                    status.innerHTML = `<span class="success">${t('import_success')}</span>`;
                    
                    fileInput.value = '';
                    nameInput.value = '';
                    
                    showOutput(t('identity_imported', { name: importedName, hash: shortHash }), 'success');
                    loadIdentities();
                } else {
                    status.innerHTML = `<span class="error">${t('error')}: ${data.error}</span>`;
                    showOutput(t('error') + ': ' + data.error, 'error');
                }
            } catch (error) {
                status.innerHTML = `<span class="error">${t('error')}: ${error}</span>`;
                showOutput(t('error') + ': ' + error, 'error');
            }
        }

        async function importFromData(format) {
            const data = document.getElementById('importData').value.trim();
            const nameInput = document.getElementById('importDataName');
            
            if (!data) {
                showOutput('_paste_data_first', 'error');
                return;
            }
            
            let suggestedName = nameInput.value.trim();
            if (!suggestedName) {
                const timestamp = new Date().getTime().toString().slice(-6);
                suggestedName = `imported_${timestamp}`;
            }
            
            showOutput(t('importing', { format: format.toUpperCase() }), 'warning');
            
            try {
                const response = await fetch('/api/identities/import/data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ data: data, format: format, suggested_name: suggestedName })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const importedName = result.name || suggestedName;
                    const rnsHash = result.rns_hash || 'N/D';
                    const shortHash = rnsHash.substring(0, 8);
                    
                    document.getElementById('importData').value = '';
                    nameInput.value = '';
                    
                    showOutput(t('identity_imported', { name: importedName, hash: shortHash }), 'success');
                    loadIdentities();
                } else {
                    showOutput(t('error') + ': ' + result.error, 'error');
                }
            } catch (error) {
                showOutput(t('error') + ': ' + error, 'error');
            }
        }
                
        async function generateNewIdentity() {
            const name = document.getElementById('newIdentityName').value.trim() || 'New_identity';
            showOutput(t('generating', { name }), 'warning');
            
            try {
                const response = await fetch('/api/identities/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(t('identity_generated', { path: data.path, info: data.info }), 'success');
                    loadIdentities();
                } else {
                    showOutput(t('error') + ': ' + data.error, 'error');
                }
            } catch (error) {
                showOutput(t('error') + ': ' + error, 'error');
            }
        }
        
        function scanAllStorage() {
            showOutput(t('scanning'), 'warning');
            loadIdentities();
            showOutput(t('scan_complete'), 'success');
        }
        
        function cleanHashFromAngleBrackets(hashInput) {
            if (!hashInput) return '';
            let cleaned = hashInput.trim();
            if (cleaned.startsWith('<') && cleaned.endsWith('>')) {
                cleaned = cleaned.substring(1, cleaned.length - 1);
            } else {
                cleaned = cleaned.replace(/^</, '').replace(/>$/, '');
            }
            return cleaned.trim().toLowerCase();
        }

        async function verifyHash() {
            const hashInput = document.getElementById('verifyHashInput').value.trim();
            
            if (!hashInput) {
                showOutput('_enter_hash', 'error');
                return;
            }
            
            const cleanHash = cleanHashFromAngleBrackets(hashInput);
            const finalHash = cleanHash.replace(/\s+/g, '');
            
            if (!finalHash) {
                showOutput('_invalid_hash', 'error');
                return;
            }
            
            if (!/^[0-9a-f]{32}$|^[0-9a-f]{64}$/.test(finalHash)) {
                showOutput(t('invalid_hash') + ` Ricevuti: ${finalHash.length}`, 'error');
                return;
            }
            
            showOutput(t('verifying', { hash: finalHash }), 'warning');
            
            try {
                const verifyResult = document.getElementById('verifyResult');
                verifyResult.innerHTML = '<div class="warning">' + t('verifying', { hash: finalHash }) + '</div>';
                
                currentVerification = {
                    originalHash: finalHash,
                    rnsHash: null,
                    type: null,
                    aspects: {},
                    isPublic: true
                };
                
                const aspectCheck = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: `rnid -R -i "${finalHash}"` })
                });
                
                const aspectData = await aspectCheck.json();
                
                let resultHTML = '';
                
                if (aspectData.success) {
                    const output = aspectData.output;
                    
                    if (output.includes('Recalled Identity <') && output.includes('for destination <')) {
                        currentVerification.type = 'aspect';
                        
                        const rnsMatch = output.match(/Recalled Identity <([^>]+)> for destination/);
                        if (rnsMatch) currentVerification.rnsHash = rnsMatch[1];
                        
                        resultHTML += `<div class="success">${t('aspect_rilevato')}</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += `<div>${t('aspect_hash_originale', { hash: finalHash })}</div>`;
                        resultHTML += `<div>${t('rns_hash_corrispondente', { hash: currentVerification.rnsHash || t('error_sconosciuto') })}</div>`;
                        resultHTML += `</div>`;
                        
                        if (currentVerification.rnsHash) {
                            resultHTML += await calculateAllAspects(currentVerification.rnsHash);
                        }
                        
                    } else if (output.includes('Recalled Identity <')) {
                        currentVerification.type = 'identity';
                        currentVerification.rnsHash = finalHash;
                        
                        resultHTML += `<div class="success">${t('rns_hash_identita')}</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += `<div>${t('rns_hash_value', { hash: finalHash })}</div>`;
                        resultHTML += `<div>${t('hash_riconosciuto')}</div>`;
                        resultHTML += `</div>`;
                        
                        resultHTML += await calculateAllAspects(finalHash);
                        
                    } else {
                        currentVerification.type = 'unknown';
                        resultHTML += `<div class="error">${t('hash_non_riconosciuto')}</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += t('hash_analisi', { hash: finalHash, length: finalHash.length });
                        resultHTML += `<ul style="margin-left: 20px; margin-top: 5px;">`;
                        resultHTML += t('aspect_list_item');
                        resultHTML += t('rns_list_item');
                        resultHTML += `</ul></div>`;
                    }
                } else {
                    resultHTML += `<div class="error">${t('error_verifica')}</div>`;
                    resultHTML += `<div style="margin-top: 5px;">${aspectData.error || t('error_sconosciuto')}</div>`;
                    currentVerification.type = 'error';
                }
                
                const addBtn = document.getElementById('addToIdentitiesBtn');
                addBtn.style.display = (currentVerification.rnsHash && (currentVerification.type === 'aspect' || currentVerification.type === 'identity')) ? 'block' : 'none';
                
                verifyResult.innerHTML = resultHTML;
                showOutput(t('verify_success', { hash: finalHash }), 'success');
                
            } catch (error) {
                console.error('Errore in verifyHash:', error);
                showOutput(t('error') + ': ' + error.message, 'error');
                document.getElementById('verifyResult').innerHTML = `<div class="error">${t('error')}: ${error.message}</div>`;
            }
        }

        async function calculateAllAspects(rnsHash) {
            const aspects = ['rnstransport.probe', 'lxmf.delivery', 'nomadnetwork.node', 'lxmf.propagation', 'call.audio', 'lxst.telephony'];
            
            let html = `<div style="margin-top: 15px;">${t('aspects_calcolati')}</div>`;
            html += `<div style="margin-top: 5px; font-size: 10px; font-family: monospace;">`;
            
            for (const aspect of aspects) {
                try {
                    const aspectResult = await fetch('/api/rnid', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ command: `rnid -R -i "${rnsHash}" -H "${aspect}"` })
                    });
                    
                    const aspectData = await aspectResult.json();
                    
                    if (aspectData.success && aspectData.output) {
                        let aspectHash = null;
                        const pattern = `The ${aspect} destination for this Identity is <`;
                        
                        for (const line of aspectData.output.split('\n')) {
                            if (line.includes(pattern)) {
                                const start = line.indexOf('<') + 1;
                                const end = line.indexOf('>', start);
                                if (start > 0 && end > start) {
                                    aspectHash = line.substring(start, end);
                                    break;
                                }
                            }
                        }
                        
                        if (aspectHash) {
                            currentVerification.aspects[aspect] = aspectHash;
                            html += `<div style="margin-top: 3px;">`;
                            html += `<span style="color:#888">${aspect}:</span> <code style="color:#0ff">${aspectHash}</code>`;
                            if (aspectHash === currentVerification.originalHash) {
                                html += ` <span style="color:#ff0; font-size:9px;">${t('aspect_originale')}</span>`;
                            }
                            html += `</div>`;
                        }
                    }
                } catch (error) {
                    html += `<div style="color:#f00; margin-top: 3px;">${t('aspect_calc_error', { aspect })}</div>`;
                }
            }
            
            html += `</div>`;
            return html;
        }

        async function addToPublicIdentities() {
            if (!currentVerification.rnsHash) {
                showOutput('_error', 'error');
                return;
            }
            
            try {
                const nameInput = document.getElementById('publicIdentityName').value.trim();
                const defaultName = `public_${currentVerification.rnsHash.substring(0, 8)}`;
                const finalName = nameInput || defaultName;
                
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                const exists = publicIdentities.some(id => id.rns_hash === currentVerification.rnsHash);
                
                if (!exists) {
                    const publicIdentity = {
                        name: finalName,
                        rns_hash: currentVerification.rnsHash,
                        aspect_hashes: currentVerification.aspects,
                        type: currentVerification.type,
                        original_hash: currentVerification.originalHash,
                        added_date: new Date().toISOString(),
                        isPublic: true
                    };
                    
                    publicIdentities.push(publicIdentity);
                    localStorage.setItem('rns_public_identities', JSON.stringify(publicIdentities));
                    
                    showOutput(t('public_identity_added', { name: finalName }), 'success');
                    
                    document.getElementById('publicIdentityName').value = '';
                    loadIdentities();
                    document.getElementById('addToIdentitiesBtn').style.display = 'none';
                    
                } else {
                    const existing = publicIdentities.find(id => id.rns_hash === currentVerification.rnsHash);
                    showOutput(t('public_identity_exists', { name: existing.name }), 'warning');
                }
                
            } catch (error) {
                showOutput(t('error') + ': ' + error, 'error');
            }
        }

        function clearVerify() {
            document.getElementById('verifyHashInput').value = '';
            document.getElementById('publicIdentityName').value = '';
            document.getElementById('verifyResult').innerHTML = '';
            document.getElementById('addToIdentitiesBtn').style.display = 'none';
            currentVerification = { originalHash: null, rnsHash: null, type: null, aspects: {}, isPublic: true };
        }

        function calculateAspectHash() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            const aspect = document.getElementById('aspectInput').value.trim();
            if (!aspect) {
                showOutput('_enter_aspect', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -H "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -H "${aspect}"`;
            }
            
            executeCommand();
        }

        async function executeCommand() {
            const command = document.getElementById('commandInput').value.trim();
            if (!command) {
                showOutput('_enter_command', 'error');
                return;
            }
            
            showOutput(t('command_executing', { command }), 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(t('command_completed', { output: data.output }), 'success');
                } else {
                    let errorMsg = t('command_error', { code: data.return_code, error: data.error || '', output: data.output || '' });
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(t('error') + ': ' + error, 'error');
            }
        }
        
        function showIdentityInfo() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" --print-identity`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} --print-identity -P`;
            }
            
            executeCommand();
        }

        function announceWithCustomAspect() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            const aspect = document.getElementById('announceAspect').value.trim();
            if (!aspect) {
                showOutput('_enter_aspect', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -a "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -a "${aspect}"`;
            }
            
            executeCommand();
        }
        
        function announceWithAspect() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            const aspect = document.getElementById('announceAspect').value.trim() || "rnstransport.probe";
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -a "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -a "${aspect}"`;
            }
            
            executeCommand();
        }

        function handleCryptoFileSelect() {
            const fileInput = document.getElementById('cryptoFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('cryptoFileStatus');
            
            if (!file) return;
            
            selectedCryptoFile = file;
            status.innerHTML = `<span class="success">${t('file_selected', { name: file.name, size: file.size })}</span>`;
            
            const fileName = file.name;
            
            if (fileName.endsWith('.enc')) {
                const baseName = fileName.substring(0, fileName.length - 4);
                document.getElementById('outputFileName').value = baseName;
            } else {
                document.getElementById('outputFileName').value = fileName + '.enc';
            }
        }

        async function encryptFile() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            if (!selectedCryptoFile) {
                showOutput('_select_file_first', 'error');
                return;
            }
            
            let outputFile = document.getElementById('outputFileName').value.trim();
            if (!outputFile) {
                showOutput('_enter_output_filename', 'error');
                return;
            }
            
            showOutput(t('upload_encrypt'), 'warning');
            
            try {
                let command = '';
                const uploadData = await uploadFileToTemp(selectedCryptoFile, 'encrypt');
                
                if (!uploadData.temp_path) throw new Error('Upload failed');
                
                const tempPath = uploadData.temp_path;
                const outputDir = uploadData.output_dir;
                const outputPath = outputDir + '/' + outputFile;
                
                if (selectedIdentity.startsWith('public:')) {
                    const rnsHash = selectedIdentity.replace('public:', '');
                    command = `rnid -R -i "${rnsHash}" -e "${tempPath}" -w "${outputPath}" -f`;
                } else {
                    showOutput(t('extracting_hash'), 'warning');
                    
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    
                    const hashResponse = await fetch('/api/rnid', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ command: `rnid -i ${cmdPath} --print-identity` })
                    });
                    
                    const hashData = await hashResponse.json();
                    let rnsHash = null;
                    
                    if (hashData.success && hashData.output) {
                        const match = hashData.output.match(/Loaded Identity <([0-9a-f]+)>/);
                        if (match) {
                            rnsHash = match[1];
                            showOutput(t('hash_found', { hash: rnsHash }), 'success');
                        }
                    }
                    
                    if (rnsHash) {
                        command = `rnid -R -i "${rnsHash}" -e "${tempPath}" -w "${outputPath}" -f`;
                    } else {
                        throw new Error('Impossibile ottenere hash RNS pubblico');
                    }
                }
                
                document.getElementById('commandInput').value = command;
                showOutput(t('command_ready', { command, path: outputPath }), 'success');
                executeCommand();
                setTimeout(() => cleanupTempFile(tempPath), 10000);
                
            } catch (error) {
                showOutput(t('error') + ': ' + error.message, 'error');
            }
        }

        async function decryptFile() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            if (!selectedCryptoFile) {
                showOutput('_select_file_first', 'error');
                return;
            }
            
            let outputFile = document.getElementById('outputFileName').value.trim();
            if (!outputFile) {
                showOutput('_enter_output_filename', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                showOutput('_private_identity_needed', 'error');
                return;
            }
            
            showOutput(t('upload_decrypt'), 'warning');
            
            try {
                const uploadData = await uploadFileToTemp(selectedCryptoFile, 'decrypt');
                const tempPath = uploadData.temp_path;
                const outputDir = uploadData.output_dir;
                const outputPath = outputDir + '/' + outputFile;
                
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                const command = `rnid -i ${cmdPath} -d "${tempPath}" -w "${outputPath}" -f`;
                
                document.getElementById('commandInput').value = command;
                showOutput(t('command_ready', { command, path: outputPath }), 'success');
                executeCommand();
                setTimeout(() => cleanupTempFile(tempPath), 10000);
                
            } catch (error) {
                showOutput(t('error') + ': ' + error.message, 'error');
            }
        }

        async function encryptText() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            const text = document.getElementById('cryptoTextInput').value.trim();
            if (!text) {
                showOutput('_enter_text', 'error');
                return;
            }
            
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const cleanCommand = 'rm -f /tmp/web_input.txt /tmp/web_encrypted.enc';
            const escapedText = text.replace(/"/g, '\\"');
            const writeCommand = `echo "${escapedText}" > /tmp/web_input.txt`;
            
            let command = '';
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                command = `${cleanCommand} && ${writeCommand} && rnid -R -i "${rnsHash}" -e /tmp/web_input.txt -w /tmp/web_encrypted.enc -f`;
            } else {
                showOutput(t('extracting_hash'), 'warning');
                
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                
                const hashResponse = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: `rnid -i ${cmdPath} --print-identity` })
                });
                
                const hashData = await hashResponse.json();
                let rnsHash = null;
                
                if (hashData.success && hashData.output) {
                    const match = hashData.output.match(/Loaded Identity <([0-9a-f]+)>/);
                    if (match) {
                        rnsHash = match[1];
                        showOutput(t('hash_found', { hash: rnsHash }), 'success');
                    }
                }
                
                if (rnsHash) {
                    command = `${cleanCommand} && ${writeCommand} && rnid -R -i "${rnsHash}" -e /tmp/web_input.txt -w /tmp/web_encrypted.enc -f`;
                } else {
                    showOutput('_error', 'error');
                    return;
                }
            }
            
            const fullCommand = `${command} && base64 /tmp/web_encrypted.enc`;
            showOutput(t('encrypting'), 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(t('success') + ' ' + data.output, 'success');
                    
                    const outputLines = data.output.trim().split('\n');
                    let base64Lines = [];
                    let foundBase64 = false;
                    
                    for (const line of outputLines) {
                        const trimmedLine = line.trim();
                        
                        if (trimmedLine && !trimmedLine.includes(' ') && /^[A-Za-z0-9+/=]+$/.test(trimmedLine)) {
                            base64Lines.push(trimmedLine);
                            foundBase64 = true;
                        }
                        else if (foundBase64 && trimmedLine && !trimmedLine.includes('Loaded Identity') && !trimmedLine.includes('Encrypting') && !trimmedLine.includes('File') && !trimmedLine.includes('rm -f') && !trimmedLine.includes('echo') && !trimmedLine.includes('base64') && !trimmedLine.includes('rnid')) {
                            base64Lines.push(trimmedLine);
                        }
                    }
                    
                    let encryptedBase64 = base64Lines.join('');
                    
                    if (!encryptedBase64) {
                        const lines = data.output.split('\n');
                        let startCollecting = false;
                        let collectedLines = [];
                        
                        for (const line of lines) {
                            if (line.includes('base64 /tmp/web_encrypted.enc')) {
                                startCollecting = true;
                                continue;
                            }
                            if (startCollecting && line.trim()) {
                                collectedLines.push(line.trim());
                            }
                        }
                        encryptedBase64 = collectedLines.join('');
                    }
                    
                    encryptedBase64 = encryptedBase64.replace(/\s+/g, '');
                    
                    document.getElementById('cryptoEncryptedOutput').value = encryptedBase64;
                    document.getElementById('cryptoEncryptedResult').style.display = 'block';
                    
                    setTimeout(() => {
                        const outputField = document.getElementById('cryptoEncryptedOutput');
                        outputField.select();
                        outputField.focus();
                    }, 100);
                    
                } else {
                    let errorMsg = t('error') + ` (code: ${data.return_code})\n`;
                    if (data.error) errorMsg += data.error + '\n';
                    if (data.output) errorMsg += data.output;
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(t('error') + ': ' + error.message, 'error');
            }
        }

        async function decryptText() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            const text = document.getElementById('cryptoTextInput').value.trim();
            if (!text) {
                showOutput('_enter_text', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                showOutput('_private_identity_needed', 'error');
                return;
            }
            
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const hasSpaces = selectedIdentity.includes(' ');
            const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
            const cleanInput = text.replace(/\s+/g, '');
            
            const fullCommand = `rm -f /tmp/web_encrypted.enc /tmp/web_decrypted.txt && ` +
                               `echo "${cleanInput}" | base64 -d > /tmp/web_encrypted.enc && ` +
                               `rnid -i ${cmdPath} -d /tmp/web_encrypted.enc -w /tmp/web_decrypted.txt -f && ` +
                               `cat /tmp/web_decrypted.txt && rm -f /tmp/web_encrypted.enc /tmp/web_decrypted.txt`;
            
            showOutput(t('decrypting'), 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const output = data.output;
                    showOutput(t('success') + ' ' + output, 'success');
                    
                    const lines = output.split('\n');
                    let decryptedLines = [];
                    
                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        
                        if (trimmedLine && !trimmedLine.includes('Loaded Identity') && !trimmedLine.includes('Decrypting') && !trimmedLine.includes('File') && !trimmedLine.includes('rm -f') && !trimmedLine.includes('echo') && !trimmedLine.includes('base64') && !trimmedLine.includes('rnid -i') && !trimmedLine.includes('cat /tmp/web_decrypted.txt') && !trimmedLine.startsWith('[') && !trimmedLine.includes('/tmp/')) {
                            decryptedLines.push(trimmedLine);
                        }
                    }
                    
                    let decryptedText = decryptedLines.join('\n');
                    
                    if (!decryptedText) {
                        for (let i = lines.length - 1; i >= 0; i--) {
                            if (lines[i].trim()) {
                                decryptedText = lines[i].trim();
                                break;
                            }
                        }
                    }
                    
                    document.getElementById('cryptoDecryptedOutput').value = decryptedText;
                    document.getElementById('cryptoDecryptedResult').style.display = 'block';
                    
                    setTimeout(() => {
                        const outputField = document.getElementById('cryptoDecryptedOutput');
                        outputField.select();
                        outputField.focus();
                    }, 100);
                    
                } else {
                    let errorMsg = t('error') + ` (code: ${data.return_code})\n`;
                    if (data.error) errorMsg += data.error + '\n';
                    if (data.output) errorMsg += data.output;
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(t('error') + ': ' + error.message, 'error');
            }
        }

        function handleSignFileSelect() {
            const fileInput = document.getElementById('signFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('signFileStatus');
            
            if (!file) return;
            
            selectedSignFile = file;
            status.innerHTML = `<span class="success">${t('file_selected', { name: file.name, size: file.size })}</span>`;
            document.getElementById('signatureFileName').value = file.name + '.rsg';
        }

        function handleSigFileSelect() {
            const fileInput = document.getElementById('sigFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('sigFileStatus');
            
            if (!file) return;
            
            selectedSigFileForVerification = file;
            status.innerHTML = `<span class="success">${t('sig_file_selected', { name: file.name })}</span>`;
        }

        async function signFile() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            if (!selectedSignFile) {
                showOutput('_select_file_first', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                showOutput('_private_identity_needed', 'error');
                return;
            }
            
            showOutput(t('signing', { name: selectedSignFile.name }), 'warning');
            
            try {
                const formData = new FormData();
                formData.append('file', selectedSignFile);
                formData.append('purpose', 'sign');
                
                const response = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) throw new Error(`Upload fallito: ${response.status}`);
                
                const uploadData = await response.json();
                if (!uploadData.success || !uploadData.temp_path) throw new Error(uploadData.error || 'Upload fallito');
                
                const tempPath = uploadData.temp_path;
                const downloadsDir = uploadData.output_dir;
                const fileName = selectedSignFile.name;
                
                const originalInDownloads = downloadsDir + '/' + fileName;
                const sigFileName = document.getElementById('signatureFileName').value.trim() || fileName + '.rsg';
                const sigInDownloads = downloadsDir + '/' + sigFileName;
                
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                const command = `cp "${tempPath}" "${originalInDownloads}" && rnid -i ${cmdPath} -s "${originalInDownloads}" -w "${sigInDownloads}" -f`;
                
                document.getElementById('commandInput').value = command;
                showOutput(t('command_ready', { command, path: sigInDownloads }), 'success');
                executeCommand();
                
                setTimeout(() => {
                    fetch('/api/cleanup/temp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ temp_path: tempPath })
                    }).catch(e => console.warn('Cleanup failed:', e));
                }, 5000);
                
            } catch (error) {
                showOutput(t('error') + ': ' + error.message, 'error');
            }
        }

        async function verifySignature() {
            if (!selectedIdentity) {
                showOutput('_select_identity_first', 'error');
                return;
            }
            
            if (!selectedSigFileForVerification) {
                showOutput('_select_sig_file_first', 'error');
                return;
            }
            
            const fileName = selectedSigFileForVerification.name;
            
            if (!fileName.toLowerCase().endsWith('.rsg')) {
                showOutput(t('error') + `: Il file deve essere una firma (.rsg)!\nRicevuto: ${fileName}`, 'error');
                return;
            }
            
            showOutput(t('verifying', { hash: fileName }), 'warning');
            
            try {
                const formData = new FormData();
                formData.append('file', selectedSigFileForVerification);
                formData.append('purpose', 'verify');
                
                const uploadResponse = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) throw new Error(`Upload fallito: ${uploadResponse.status}`);
                
                const uploadData = await uploadResponse.json();
                if (!uploadData.success || !uploadData.temp_path) throw new Error(uploadData.error || 'Upload fallito');
                
                const tempPath = uploadData.temp_path;
                const downloadsDir = uploadData.output_dir;
                const sigFileName = selectedSigFileForVerification.name;
                const sigInDownloads = downloadsDir + '/' + sigFileName;
                
                const copyCommand = `cp "${tempPath}" "${sigInDownloads}"`;
                
                let verifyCommand;
                if (selectedIdentity.startsWith('public:')) {
                    const rnsHash = selectedIdentity.replace('public:', '');
                    verifyCommand = `rnid -R -i "${rnsHash}" -V "${sigInDownloads}"`;
                } else {
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    verifyCommand = `rnid -i ${cmdPath} -V "${sigInDownloads}"`;
                }
                
                const fullCommand = `${copyCommand} && ${verifyCommand}`;
                
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                
                const verifySection = document.getElementById('verifyResultSection');
                const verifyOutput = document.getElementById('verifyResultOutput');
                
                if (verifySection && verifyOutput) {
                    verifySection.style.display = 'block';
                    
                    if (data.success) {
                        const output = data.output || '';
                        
                        if (output.includes('is valid') && !output.includes('is invalid')) {
                            verifyOutput.value = t('valid_signature') + '\n\n' + output;
                            showOutput(t('valid_signature'), 'success');
                        } else if (output.includes('is invalid')) {
                            verifyOutput.value = t('invalid_signature') + '\n\n' + output;
                            showOutput(t('invalid_signature'), 'error');
                        } else {
                            verifyOutput.value = t('warning') + '\n\n' + output;
                            showOutput(t('warning'), 'warning');
                        }
                    } else {
                        verifyOutput.value = t('error') + '\n\n' + (data.error || data.output || t('error_sconosciuto'));
                        showOutput(t('error'), 'error');
                    }
                }
                
                setTimeout(() => {
                    fetch('/api/cleanup/temp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ temp_path: tempPath })
                    }).catch(e => console.warn('Cleanup ignorato:', e));
                }, 3000);
                
            } catch (error) {
                showOutput(t('error') + ': ' + error.message, 'error');
            }
        }

        function copyVerifyResult() {
            const output = document.getElementById('verifyResultOutput');
            if (!output || !output.value.trim()) {
                showOutput(t('no_data_to_copy'), 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput(t('copy_success'), 'success');
            } catch (err) {
                showOutput(t('copy_error_details', { error: err }), 'error');
            }
        }

        async function uploadFileToTemp(file, purpose = 'crypto') {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('purpose', purpose);
            
            try {
                const response = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    return { success: true, temp_path: data.temp_path, output_dir: data.output_dir, original_name: data.original_name };
                } else {
                    return { success: false, error: data.error || 'Upload failed' };
                }
            } catch (error) {
                return { success: false, error: `Upload error: ${error.message}` };
            }
        }

        async function cleanupTempFile(tempPath) {
            try {
                await fetch('/api/cleanup/temp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ temp_path: tempPath })
                });
            } catch (error) {
                console.warn('Cleanup failed:', error);
            }
        }

        function copyEncryptedResult() {
            const output = document.getElementById('cryptoEncryptedOutput');
            if (!output || !output.value.trim()) {
                showOutput(t('no_data_to_copy'), 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput(t('copy_success'), 'success');
            } catch (err) {
                showOutput(t('copy_error_details', { error: err }), 'error');
            }
        }

        function copyDecryptedResult() {
            const output = document.getElementById('cryptoDecryptedOutput');
            if (!output || !output.value.trim()) {
                showOutput(t('no_data_to_copy'), 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput(t('copy_success'), 'success');
            } catch (err) {
                showOutput(t('copy_error_details', { error: err }), 'error');
            }
        }

        function clearCryptoText() {
            document.getElementById('cryptoTextInput').value = '';
            document.getElementById('cryptoEncryptedOutput').value = '';
            document.getElementById('cryptoDecryptedOutput').value = '';
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const cleanCommand = 'rm -f /tmp/web_input.txt /tmp/web_encrypted.enc /tmp/web_decrypted.txt';
            
            fetch('/api/rnid', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command: cleanCommand })
            }).catch(() => {});
            
            showOutput(t('cleanup_text'), 'warning');
        }
        
        function showOutput(message, type = '') {
            const output = document.getElementById('output');
            const escapedMessage = message.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            const className = type ? ` class="${type}"` : '';
            output.innerHTML = `<pre style="margin:0; padding:0; font-family:inherit; font-size:inherit; white-space:pre-wrap; word-wrap:break-word;"${className}>${escapedMessage}</pre>`;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearCommand() {
            document.getElementById('commandInput').value = '';
        }
        
        document.addEventListener('touchstart', function(event) {
            if (event.touches.length > 1) {
                event.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>