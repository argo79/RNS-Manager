<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RNID Identity Manager</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="/static/rns_manager.css">
</head>
<body class="id-mgr">  <!-- Aggiungi questa classe -->
    <div class="container">
        <header>
            <div class="header-title">
                <h1>RETICULUM IDENTITY MANAGER GUI 1.0.0</h1>
                <div>Gestione identit√† Reticulum</div>
            </div>
            <div>
                <a href="/monitor" class="monitor-button">
                    üì° APRI MONITOR
                </a>
            </div>
        </header>
        
        <div class="row">
            <!-- COLONNA 1: Gestione Identit√† -->
            <div class="col">
                <div class="section">
                    <h2>IDENTIT√Ä DISPONIBILI</h2>
                    <div class="button-group">
                        <button onclick="loadIdentities()">üîÑ Carica</button>
                        <button class="secondary" onclick="scanAllStorage()">üîç Cerca</button>
                    </div>
                    
                    <div id="identitiesList" class="identities-list">
                        <div class="warning"> Premi "Carica" per visualizzare le identit√†</div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="tabs">
                        <div class="tab active" onclick="showTab('import-tab')">IMPORT</div>
                        <div class="tab" onclick="showTab('export-tab')">EXPORT</div>
                        <div class="tab" onclick="showTab('generate-tab')">GENERA</div>
                    </div>
                    
                    <!-- IMPORT TAB -->
                    <div id="import-tab" class="tab-content active">
                        <div class="form-group">
                            <label>Importa da file (64 bytes):</label>
                            <div class="file-input-wrapper">
                                <button>üìÅ Scegli file identit√†</button>
                                <input type="file" id="fileImport" accept="*" onchange="handleFileImport()">
                            </div>
                            <div class="form-group" style="margin-top: 8px;">
                                <label>Nome identit√† (opzionale):</label>
                                <input type="text" id="importFileName" 
                                       placeholder="es: nodo_remoto, server_backup, ecc."
                                       style="font-family: inherit; font-size: 11px; width: 100%;">
                                <div style="font-size: 10px; color: #888; margin-top: 2px;">
                                    Se lasciato vuoto, verr√† generato automaticamente
                                </div>
                            </div>
                            <div id="fileImportStatus" style="font-size:10px; margin-top:4px;"></div>
                        </div>
                        
                        <div class="form-group">
                            <label>Oppure importa da dati:</label>
                            <div class="button-group">
                                <button class="secondary" onclick="importFromData('hex')">HEX</button>
                                <button class="secondary" onclick="importFromData('base32')">Base32</button>
                                <button class="secondary" onclick="importFromData('base64')">Base64</button>
                            </div>
                            <div class="form-group" style="margin-top: 8px;">
                                <label>Nome identit√† (opzionale):</label>
                                <input type="text" id="importDataName" 
                                       placeholder="es: nodo_remoto, server_backup, ecc."
                                       style="font-family: inherit; font-size: 11px; width: 100%;">
                            </div>
                            <textarea id="importData" placeholder="Incolla i dati identit√† qui..."></textarea>
                        </div>
                    </div>

                    <!-- EXPORT TAB -->
                    <div id="export-tab" class="tab-content">
                        <div class="form-group">
                            <label>Esporta identit√† selezionata:</label>
                            <div class="button-group">
                                <button onclick="exportIdentity('hex')">HEX</button>
                                <button onclick="exportIdentity('base32')">Base32</button>
                                <button onclick="exportIdentity('base64')">Base64</button>
                            </div>
                            <div id="exportResult" style="margin-top:8px;"></div>
                        </div>
                    </div>
                    
                    <!-- GENERATE TAB -->
                    <div id="generate-tab" class="tab-content">
                        <div class="form-group">
                            <label>Nome nuova identit√†:</label>
                            <input type="text" id="newIdentityName" placeholder="es: New_identity" value="New_identity">
                            <button onclick="generateNewIdentity()">Genera Identit√†</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- COLONNA 2: Operazioni & Analytics -->
            <div class="col">                
                
                <div class="section">
                    <h2>VERIFICA & ANALISI HASH</h2>
                    <div class="form-group">
                        <label>Inserisci hash (32 bytes HEX):</label>
                        <input type="text" id="verifyHashInput" 
                               placeholder="Es: bd96b8a833b14e64d57e781c3e7e4836"
                               style="font-family: monospace; font-size: 11px; width: 100%;">
                        
                        <label style="margin-top: 8px;">Nome identit√† (opzionale):</label>
                        <input type="text" id="publicIdentityName" 
                               placeholder="Es: remote node"
                               style="font-family: inherit; font-size: 11px; width: 100%;">
                        
                        <div class="button-group">
                            <button onclick="verifyHash()">üîç Analizza</button>
                            <button class="secondary" onclick="clearVerify()">üóë Pulisci</button>
                            <button class="secondary" onclick="addToPublicIdentities()" id="addToIdentitiesBtn" style="display:none;">‚ûï Aggiungi alle Pubbliche</button>
                        </div>
                    </div>
                    
                    <div id="verifyResult" style="margin-top: 10px; font-size: 11px; max-height: 300px; overflow-y: auto; padding: 8px; background: #111; border: 1px solid #333; border-radius: 3px;"></div>
                </div>

                <div class="section">
                    <h2>CALCOLO HASH ASPECT</h2>
                    <div class="aspect-input-group">
                        <input type="text" id="aspectInput" placeholder="Inserisci aspect RNS" value="rnstransport.probe">
                        <button onclick="calculateAspectHash()">üî¢ Calcola</button>
                    </div>
                    
                    <div class="aspect-buttons">
                        <button class="aspect-btn" onclick="setAspect('rnstransport.probe')">rnstransport.probe</button>
                        <button class="aspect-btn" onclick="setAspect('lxmf.delivery')">lxmf.delivery</button>
                        <button class="aspect-btn" onclick="setAspect('nomadnetwork.node')">nomadnetwork.node</button>
                        <button class="aspect-btn" onclick="setAspect('lxmf.propagation')">lxmf.propagation</button>
                        <button class="aspect-btn" onclick="setAspect('call.audio')">call.audio</button>
                        <button class="aspect-btn" onclick="setAspect('lxst.telephony')">lxst.telephony</button>
                    </div>
                </div>

                <!-- SEZIONE CIFRATURA & DECIFRATURA -->
                <div class="section">
                    <h2>üîê CIFRATURA & DECIFRATURA</h2>
                    
                    <div class="tabs" id="crypto-tabs">
                        <div class="tab active" onclick="showCryptoTab('crypto-file-tab')">üìÅ File</div>
                        <div class="tab" onclick="showCryptoTab('crypto-text-tab')">üìù Testo</div>
                    </div>
                    
                    <!-- TAB FILE -->
                    <div id="crypto-file-tab" class="tab-content active">
                        <div class="form-group">
                            <label>File input:</label>
                            <div class="file-input-wrapper">
                                <button>üìÅ Scegli file</button>
                                <input type="file" id="cryptoFileInput" accept="*" onchange="handleCryptoFileSelect()">
                            </div>
                            <div id="cryptoFileStatus" style="font-size:10px; margin-top:4px;"></div>
                        </div>
                        
                        <div class="form-group">
                            <label>File output:</label>
                            <input type="text" id="outputFileName" 
                                   placeholder="es: output.txt.enc o output.txt"
                                   style="font-family: monospace; font-size: 11px;">
                        </div>
                        
                        <div class="button-group">
                            <button onclick="encryptFile()">üîí Cifra File</button>
                            <button onclick="decryptFile()">üîì Decifra File</button>
                        </div>
                    </div>
                    
                    <!-- TAB TESTO -->
                    <div id="crypto-text-tab" class="tab-content">
                        <div class="form-group">
                            <label>Testo da cifrare/decifrare:</label>
                            <textarea id="cryptoTextInput" 
                                     placeholder="Incolla il testo qui..."
                                     style="height: 80px; font-family: monospace; font-size: 11px;"></textarea>
                        </div>
                        
                        <div class="button-group">
                            <button onclick="encryptText()">üîí Cifra Testo</button>
                            <button onclick="decryptText()">üîì Decifra Testo</button>
                            <button class="secondary" onclick="clearCryptoText()">üóë Pulisci</button>
                        </div>
                        
                        <!-- RISULTATO CIFRATO -->
                        <div id="cryptoEncryptedResult" style="margin-top: 10px; display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <label style="margin: 0; font-size: 11px;">Testo cifrato:</label>
                                <button class="crypto-copy-btn" onclick="copyEncryptedResult()">
                                    üìã Copia
                                </button>
                            </div>
                            <textarea id="cryptoEncryptedOutput" 
                                     readonly
                                     style="width:100%; height: 60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                     onclick="this.select()"></textarea>
                        </div>
                        
                        <!-- RISULTATO DECIFRATO -->
                        <div id="cryptoDecryptedResult" style="margin-top: 10px; display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <label style="margin: 0; font-size: 11px;">Testo decifrato:</label>
                                <button class="crypto-copy-btn" onclick="copyDecryptedResult()">
                                    üìã Copia
                                </button>
                            </div>
                            <textarea id="cryptoDecryptedOutput" 
                                     readonly
                                     style="width:100%; height: 60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                     onclick="this.select()"></textarea>
                        </div>
                    </div>
                </div>

                <!-- SEZIONE FIRMA & VERIFICA FIRMA -->
                <div class="section">
                    <h2>‚úçÔ∏è FIRMA & VERIFICA FIRMA</h2>
                    
                    <div class="form-group">
                        <label>File da firmare/verificare:</label>
                        <div class="file-input-wrapper">
                            <button>üìÅ Scegli file</button>
                            <input type="file" id="signFileInput" accept="*" onchange="handleSignFileSelect()">
                        </div>
                        <div id="signFileStatus" style="font-size:10px; margin-top:4px;"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>File firma .rsg (solo per verifica):</label>
                        <div class="file-input-wrapper">
                            <button>üìÅ Scegli file .rsg</button>
                            <input type="file" id="sigFileInput" accept=".rsg" onchange="handleSigFileSelect()">
                        </div>
                        <div id="sigFileStatus" style="font-size:10px; margin-top:4px;"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>File firma output (.rsg):</label>
                        <input type="text" id="signatureFileName" 
                               placeholder="es: documento.rsg"
                               style="font-family: monospace; font-size: 11px; width: 100%;"
                               value="">
                    </div>
                    
                    <div class="button-group">
                        <button onclick="signFile()">‚úçÔ∏è Firma File</button>
                        <button onclick="verifySignature()">‚úÖ Verifica Firma</button>
                    </div>
                    
                    <!-- RISULTATO VERIFICA -->
                    <div id="verifyResultSection" style="margin-top: 10px; display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <label style="margin: 0; font-size: 11px;">Risultato verifica:</label>
                            <button class="crypto-copy-btn" onclick="copyVerifyResult()">
                                üìã Copia
                            </button>
                        </div>
                        <textarea id="verifyResultOutput" 
                                 readonly
                                 style="width:100%; height: 80px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                 onclick="this.select()"></textarea>
                    </div>
                </div>
            </div>
            
            <!-- COLONNA 3: Interazione & Output -->
            <div class="col">
                <div class="section">
                    <h2>INFORMAZIONI IDENTIT√Ä</h2>
                    <div class="button-group">
                        <button class="secondary" onclick="showIdentityInfo()">‚Ñπ Info Identit√†</button>
                        <button class="secondary" onclick="announceWithAspect()">üì¢ Annuncia</button>
                    </div>
                    
                    <div class="aspect-input-group" style="margin-top: 10px;">
                        <input type="text" id="announceAspect" placeholder="Aspect da annunciare" value="rnstransport.probe">
                        <button class="secondary" onclick="announceWithCustomAspect()">üì¢ Annuncia Custom</button>
                    </div>
                </div>
                
                <!-- SEZIONE COMANDI RNID -->
                <div class="section">
                    <h2>COMANDI RNID</h2>
                    <div class="command-area">
                        <textarea id="commandInput">rnid -h</textarea>
                        <div class="button-group">
                            <button onclick="executeCommand()">‚ñ∂ Esegui</button>
                            <button class="secondary" onclick="clearCommand()">üóë Pulisci</button>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>OUTPUT</h2>
                    <div id="output" class="output"></div>
                </div>
                
                <div class="section">
                    <h2>INFORMAZIONI</h2>
                    <div style="font-size: 11px; color: #888; line-height: 1.3;">
                        <div style="margin-bottom: 5px;">
                            <strong>Formati supportati:</strong>
                        </div>
                        <div style="margin-bottom: 3px;">‚Ä¢ <strong>HEX</strong>: 128 caratteri</div>
                        <div style="margin-bottom: 3px;">‚Ä¢ <strong>BASE32</strong>: maiuscolo, con '='</div>
                        <div style="margin-bottom: 3px;">‚Ä¢ <strong>BASE64</strong>: standard, con '=='</div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333;">
                            <strong>Aspects RNS:</strong> rnstransport.probe, lxmf.delivery, nomadnetwork.node, lxmf.propagation, call.audio, lxst.telephony
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedIdentity = null;
        let lastExportedData = null;
        let selectedSigFileForVerification = null;
        let selectedCryptoFile = null;
        let selectedSignFile = null;
        let currentVerification = {
            originalHash: null,
            rnsHash: null,
            type: null,
            aspects: {},
            isPublic: true
        };

        // Tab management
        function showTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }
        
        function showCryptoTab(tabId) {
            document.querySelectorAll('#crypto-tabs .tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('#crypto-tabs ~ .tab-content, #crypto-tabs + .tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }
        
        // Funzione per impostare aspect
        function setAspect(aspect) {
            document.getElementById('aspectInput').value = aspect;
            document.getElementById('announceAspect').value = aspect;
            if (selectedIdentity) {
                if (selectedIdentity.startsWith('public:')) {
                    const rnsHash = selectedIdentity.replace('public:', '');
                    document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -H "${aspect}"`;
                } else {
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    document.getElementById('commandInput').value = `rnid -i ${cmdPath} -H "${aspect}"`;
                }
            }
        }
        
        // Load identities - SOLO SU RICHIESTA
        async function loadIdentities() {
            const list = document.getElementById('identitiesList');
            list.innerHTML = '<div class="warning">Caricamento...</div>';
            
            try {
                const response = await fetch('/api/identities/list');
                const backendData = await response.json();
                const backendIdentities = backendData.identities || [];
                
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                
                if (backendIdentities.length === 0 && publicIdentities.length === 0) {
                    list.innerHTML = '<div class="warning">Nessuna identit√† trovata</div>';
                    return;
                }
                
                let html = '';
                
                backendIdentities.forEach(identity => {
                    html += renderIdentityItem(identity, false);
                });
                
                publicIdentities.forEach(identity => {
                    identity.isPublic = true;
                    html += renderIdentityItem(identity, true);
                });
                
                list.innerHTML = html;
                
            } catch (error) {
                console.error('Errore loadIdentities:', error);
                list.innerHTML = `<div class="error">Errore: ${error}</div>`;
            }
        }

        function renderIdentityItem(identity, isPublic = false) {
            const validClass = isPublic ? 'success' : (identity.valid ? 'success' : 'warning');
            
            let sizeInfo = '';
            if (identity.size) {
                sizeInfo = identity.size === 64 ? '64 bytes ‚úì' : `${identity.size} bytes`;
            } else {
                sizeInfo = isPublic ? '32 bytes (pubblica)' : '? bytes';
            }
            
            const name = identity.name || (isPublic ? `public_${identity.rns_hash?.substring(0, 8)}` : 'unknown');
            const app = identity.app || (isPublic ? 'public' : 'unknown');
            
            let hashInfo = '';
            const rnsHash = identity.rns_hash || identity.rnsHash;
            if (rnsHash) {
                const shortHash = rnsHash.length > 32 ? 
                    rnsHash.substring(0, 32) + '...' : rnsHash;
                hashInfo = `<div style="font-size: 10px; color: #0ff; font-family: monospace; margin-top: 2px;">
                            RNS: ${shortHash}
                           </div>`;
            }
            
            let aspectInfo = '';
            const rnsAspects = ['rnstransport.probe', 'lxmf.delivery', 'nomadnetwork.node', 'lxmf.propagation', 'call.audio', 'lxst.telephony'];
            
            const aspectHashes = identity.aspect_hashes || identity.aspects || {};
            
            rnsAspects.forEach(aspect => {
                if (aspectHashes[aspect]) {
                    const hash = aspectHashes[aspect];
                    const shortHash = hash.length > 32 ? hash.substring(0, 32) + '...' : hash;
                    aspectInfo += `<div style="font-size: 9px; color: ${isPublic ? '#8f8' : '#888'}; margin-top: 1px;">
                                 ${aspect.split('.')[0]}: ${shortHash}
                                 </div>`;
                }
            });
            
            let deleteButton = '';
            if (isPublic && rnsHash) {
                deleteButton = `<button onclick="event.stopPropagation(); removePublicIdentity('${rnsHash}')" 
                                  style="background: #f44; color: white; border: none; padding: 2px 5px; font-size: 9px; border-radius: 2px; margin-left: 5px; cursor: pointer; vertical-align: middle;">
                                  ‚úï
                               </button>`;
            }
            
            return `
                <div class="identity-item" onclick="${isPublic ? `selectPublicIdentity('${rnsHash}', this)` : `selectIdentity('${identity.path}', this)`}">
                    <div style="flex: 1;">
                        <div class="identity-name">${name} ${isPublic ? 'üåê' : 'üîë'} ${deleteButton}</div>
                        <div class="identity-info">
                            ${sizeInfo} ‚Ä¢ ${app}
                            ${hashInfo}
                            ${aspectInfo}
                        </div>
                    </div>
                    <span class="identity-badge ${validClass}">
                        ${isPublic ? 'PUBBLICA' : (identity.valid ? 'PRIVATA' : 'VERIF')}
                    </span>
                </div>
            `;
        }

        function removePublicIdentity(rnsHash) {
            if (!confirm('Sei sicuro di voler rimuovere questa identit√† pubblica?')) {
                return;
            }
            
            try {
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                const filteredIdentities = publicIdentities.filter(id => id.rns_hash !== rnsHash);
                
                localStorage.setItem('rns_public_identities', JSON.stringify(filteredIdentities));
                
                showOutput(`‚úÖ Identit√† pubblica rimossa`, 'success');
                loadIdentities();
            } catch (error) {
                showOutput(`‚ùå Errore nella rimozione: ${error}`, 'error');
            }
        }

        function selectPublicIdentity(rnsHash, element) {
            document.querySelectorAll('.identity-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            element.classList.add('selected');
            selectedIdentity = `public:${rnsHash}`;
            
            document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" --print-identity`;
            
            showOutput(`‚úÖ Selezionata identit√† pubblica: ${rnsHash}`, 'success');
        }
        
        function selectIdentity(path, element) {
            document.querySelectorAll('.identity-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            element.classList.add('selected');
            selectedIdentity = path;
            
            const hasSpaces = path.includes(' ');
            const cmdPath = hasSpaces ? `"${path}"` : path;
            document.getElementById('commandInput').value = `rnid -i ${cmdPath} --print-identity -P`;
            
            showOutput(`‚úÖ Selezionata: ${path.split('/').pop()}`, 'success');
        }
        
        async function exportIdentity(format) {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            showOutput(`Esportazione in ${format}...`, 'warning');
            
            try {
                const response = await fetch('/api/identities/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: selectedIdentity, format })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    lastExportedData = { format: format, data: data.data };
                    
                    const output = document.getElementById('exportResult');
                    output.innerHTML = `
                        <div style="margin-bottom: 8px;">
                            <span class="success">‚úÖ Esportato in ${format.toUpperCase()}</span>
                        </div>
                        
                        <div class="export-buttons">
                            <button class="copy-btn" onclick="copyExportedData()">üìã Copia ${format.toUpperCase()}</button>
                        </div>
                        
                        <textarea id="exportedData" readonly 
                            style="width:100%; height:60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: vertical;">
${data.data}
                        </textarea>
                        
                        <div style="margin-top:8px; font-size:10px; color:#888;">
                            Lunghezza: ${data.length} caratteri
                        </div>
                    `;
                    
                    showOutput(`‚úÖ Esportazione ${format} completata`, 'success');
                } else {
                    showOutput(`‚ùå Errore: ${data.error}`, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }
        
        function copyExportedData() {
            const textarea = document.getElementById('exportedData');
            if (!textarea || !textarea.value) {
                showOutput('‚ùå Nessun dato da copiare', 'error');
                return;
            }
            
            let textToCopy = textarea.value.trim();
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                showOutput(`‚úÖ ${lastExportedData.format.toUpperCase()} copiato!`, 'success');
            }).catch(err => {
                textarea.select();
                document.execCommand('copy');
                showOutput(`‚úÖ ${lastExportedData.format.toUpperCase()} copiato!`, 'success');
            });
        }
        
        async function handleFileImport() {
            const fileInput = document.getElementById('fileImport');
            const file = fileInput.files[0];
            const status = document.getElementById('fileImportStatus');
            const nameInput = document.getElementById('importFileName');
            
            if (!file) {
                showOutput('‚ùå Seleziona prima un file!', 'error');
                return;
            }
            
            let suggestedName = nameInput.value.trim();
            if (!suggestedName) {
                const timestamp = new Date().getTime().toString().slice(-6);
                suggestedName = `imported_${timestamp}`;
            }
            
            status.innerHTML = `Importazione...`;
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('suggested_name', suggestedName);
            
            try {
                const response = await fetch('/api/identities/import/file', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const importedName = data.name || suggestedName;
                    const rnsHash = data.rns_hash || 'N/D';
                    const shortHash = rnsHash.substring(0, 8);
                    
                    status.innerHTML = `<span class="success">‚úÖ Importato come "${importedName}"</span>`;
                    
                    fileInput.value = '';
                    nameInput.value = '';
                    
                    showOutput(`‚úÖ Identit√† importata!\nNome: ${importedName}\nRNS: ${shortHash}...`, 'success');
                    loadIdentities();
                } else {
                    status.innerHTML = `<span class="error">‚ùå ${data.error}</span>`;
                    showOutput(`‚ùå Errore: ${data.error}`, 'error');
                }
            } catch (error) {
                status.innerHTML = `<span class="error">‚ùå ${error}</span>`;
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }

        async function importFromData(format) {
            const data = document.getElementById('importData').value.trim();
            const nameInput = document.getElementById('importDataName');
            
            if (!data) {
                showOutput('‚ùå Incolla i dati identit√† prima!', 'error');
                return;
            }
            
            let suggestedName = nameInput.value.trim();
            if (!suggestedName) {
                const timestamp = new Date().getTime().toString().slice(-6);
                suggestedName = `imported_${timestamp}`;
            }
            
            showOutput(`Importazione ${format}...`, 'warning');
            
            try {
                const response = await fetch('/api/identities/import/data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        data: data, 
                        format: format,
                        suggested_name: suggestedName
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const importedName = result.name || suggestedName;
                    const rnsHash = result.rns_hash || 'N/D';
                    const shortHash = rnsHash.substring(0, 8);
                    
                    document.getElementById('importData').value = '';
                    nameInput.value = '';
                    
                    showOutput(`‚úÖ Importato\nNome: ${importedName}\nRNS: ${shortHash}...`, 'success');
                    loadIdentities();
                } else {
                    showOutput(`‚ùå Errore: ${result.error}`, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }
                
        async function generateNewIdentity() {
            const name = document.getElementById('newIdentityName').value.trim() || 'New_identity';
            
            showOutput(`Generazione "${name}"...`, 'warning');
            
            try {
                const response = await fetch('/api/identities/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(`‚úÖ Generata: ${data.path}\n${data.info}`, 'success');
                    loadIdentities();
                } else {
                    showOutput(`‚ùå Errore: ${data.error}`, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }
        
        function scanAllStorage() {
            showOutput('üîç Scansione storage...', 'warning');
            loadIdentities();
            showOutput('‚úÖ Scansione completata', 'success');
        }
        
        function cleanHashFromAngleBrackets(hashInput) {
            if (!hashInput) return '';
            let cleaned = hashInput.trim();
            if (cleaned.startsWith('<') && cleaned.endsWith('>')) {
                cleaned = cleaned.substring(1, cleaned.length - 1);
            } else {
                cleaned = cleaned.replace(/^</, '').replace(/>$/, '');
            }
            cleaned = cleaned.trim();
            return cleaned.toLowerCase();
        }

        async function verifyHash() {
            const hashInput = document.getElementById('verifyHashInput').value.trim();
            
            if (!hashInput) {
                showOutput('‚ùå Inserisci un hash da verificare!', 'error');
                return;
            }
            
            const cleanHash = cleanHashFromAngleBrackets(hashInput);
            const finalHash = cleanHash.replace(/\s+/g, '');
            
            if (!finalHash) {
                showOutput('‚ùå Hash non valido dopo la pulizia!', 'error');
                return;
            }
            
            if (!/^[0-9a-f]{32}$|^[0-9a-f]{64}$/.test(finalHash)) {
                showOutput(`‚ùå Hash deve essere 32 o 64 caratteri esadecimali. Ricevuti: ${finalHash.length} (${finalHash})`, 'error');
                return;
            }
            
            showOutput(`üîç Analisi hash: ${finalHash}`, 'warning');
            
            try {
                const verifyResult = document.getElementById('verifyResult');
                verifyResult.innerHTML = '<div class="warning">Analisi in corso...</div>';
                
                currentVerification = {
                    originalHash: finalHash,
                    rnsHash: null,
                    type: null,
                    aspects: {},
                    isPublic: true
                };
                
                const aspectCheck = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: `rnid -R -i "${finalHash}"` })
                });
                
                const aspectData = await aspectCheck.json();
                
                let resultHTML = '';
                
                if (aspectData.success) {
                    const output = aspectData.output;
                    
                    if (output.includes('Recalled Identity <') && output.includes('for destination <')) {
                        currentVerification.type = 'aspect';
                        
                        const rnsMatch = output.match(/Recalled Identity <([^>]+)> for destination/);
                        if (rnsMatch) {
                            currentVerification.rnsHash = rnsMatch[1];
                        }
                        
                        resultHTML += `<div class="success">‚úÖ ASPECT HASH RILEVATO (64 chars)</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += `<div><strong>Aspect hash originale (64 chars):</strong> <code style="color:#0ff">${finalHash}</code></div>`;
                        resultHTML += `<div><strong>RNS Hash corrispondente (32 chars):</strong> <code style="color:#0ff">${currentVerification.rnsHash || 'Non trovato'}</code></div>`;
                        resultHTML += `</div>`;
                        
                        if (currentVerification.rnsHash) {
                            resultHTML += await calculateAllAspects(currentVerification.rnsHash);
                        }
                        
                    } else if (output.includes('Recalled Identity <')) {
                        currentVerification.type = 'identity';
                        currentVerification.rnsHash = finalHash;
                        
                        resultHTML += `<div class="success">‚úÖ RNS HASH (IDENTIT√Ä PUBBLICA - 32 chars)</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += `<div><strong>RNS Hash (32 chars):</strong> <code style="color:#0ff">${finalHash}</code></div>`;
                        resultHTML += `<div><em>Hash riconosciuto come identit√† RNS pubblica</em></div>`;
                        resultHTML += `</div>`;
                        
                        resultHTML += await calculateAllAspects(finalHash);
                        
                    } else {
                        currentVerification.type = 'unknown';
                        resultHTML += `<div class="error">‚ùå HASH NON RICONOSCIUTO</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += `<div>L'hash <code>${finalHash}</code> (${finalHash.length} chars) non √® stato riconosciuto come:</div>`;
                        resultHTML += `<ul style="margin-left: 20px; margin-top: 5px;">`;
                        resultHTML += `<li>Aspect hash (64 caratteri hex)</li>`;
                        resultHTML += `<li>RNS hash (32 caratteri hex)</li>`;
                        resultHTML += `</ul>`;
                        resultHTML += `</div>`;
                    }
                } else {
                    resultHTML += `<div class="error">‚ùå ERRORE NELLA VERIFICA</div>`;
                    resultHTML += `<div style="margin-top: 5px;">${aspectData.error || 'Errore sconosciuto'}</div>`;
                    currentVerification.type = 'error';
                }
                
                const addBtn = document.getElementById('addToIdentitiesBtn');
                if (currentVerification.rnsHash && (currentVerification.type === 'aspect' || currentVerification.type === 'identity')) {
                    addBtn.style.display = 'block';
                } else {
                    addBtn.style.display = 'none';
                }
                
                verifyResult.innerHTML = resultHTML;
                showOutput(`‚úÖ Analisi completata per: ${finalHash}`, 'success');
                
            } catch (error) {
                console.error('Errore in verifyHash:', error);
                showOutput(`‚ùå Errore durante la verifica: ${error.message}`, 'error');
                document.getElementById('verifyResult').innerHTML = `<div class="error">Errore: ${error.message}</div>`;
            }
        }

        async function calculateAllAspects(rnsHash) {
            const aspects = [
                'rnstransport.probe',
                'lxmf.delivery', 
                'nomadnetwork.node',
                'lxmf.propagation',
                'call.audio',
                'lxst.telephony'
            ];
            
            let html = `<div style="margin-top: 15px;"><strong>ASPECTS HASH CALCOLATI:</strong></div>`;
            html += `<div style="margin-top: 5px; font-size: 10px; font-family: monospace;">`;
            
            for (const aspect of aspects) {
                try {
                    const aspectResult = await fetch('/api/rnid', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            command: `rnid -R -i "${rnsHash}" -H "${aspect}"` 
                        })
                    });
                    
                    const aspectData = await aspectResult.json();
                    
                    if (aspectData.success && aspectData.output) {
                        let aspectHash = null;
                        const pattern = `The ${aspect} destination for this Identity is <`;
                        
                        for (const line of aspectData.output.split('\n')) {
                            if (line.includes(pattern)) {
                                const start = line.indexOf('<') + 1;
                                const end = line.indexOf('>', start);
                                if (start > 0 && end > start) {
                                    aspectHash = line.substring(start, end);
                                    break;
                                }
                            }
                        }
                        
                        if (aspectHash) {
                            currentVerification.aspects[aspect] = aspectHash;
                            html += `<div style="margin-top: 3px;">`;
                            html += `<span style="color:#888">${aspect}:</span> `;
                            html += `<code style="color:#0ff">${aspectHash}</code>`;
                            
                            if (aspectHash === currentVerification.originalHash) {
                                html += ` <span style="color:#ff0; font-size:9px;">‚Üê ORIGINALE</span>`;
                            }
                            
                            html += `</div>`;
                        }
                    }
                } catch (error) {
                    html += `<div style="color:#f00; margin-top: 3px;">${aspect}: Errore nel calcolo</div>`;
                }
            }
            
            html += `</div>`;
            return html;
        }

        async function addToPublicIdentities() {
            if (!currentVerification.rnsHash) {
                showOutput('‚ùå Nessun RNS hash disponibile da aggiungere', 'error');
                return;
            }
            
            try {
                const nameInput = document.getElementById('publicIdentityName').value.trim();
                const defaultName = `public_${currentVerification.rnsHash.substring(0, 8)}`;
                const finalName = nameInput || defaultName;
                
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                
                const exists = publicIdentities.some(id => id.rns_hash === currentVerification.rnsHash);
                
                if (!exists) {
                    const publicIdentity = {
                        name: finalName,
                        rns_hash: currentVerification.rnsHash,
                        aspect_hashes: currentVerification.aspects,
                        type: currentVerification.type,
                        original_hash: currentVerification.originalHash,
                        added_date: new Date().toISOString(),
                        isPublic: true
                    };
                    
                    publicIdentities.push(publicIdentity);
                    localStorage.setItem('rns_public_identities', JSON.stringify(publicIdentities));
                    
                    showOutput(`‚úÖ Identit√† pubblica "${finalName}" aggiunta!`, 'success');
                    
                    document.getElementById('publicIdentityName').value = '';
                    loadIdentities();
                    document.getElementById('addToIdentitiesBtn').style.display = 'none';
                    
                } else {
                    const existing = publicIdentities.find(id => id.rns_hash === currentVerification.rnsHash);
                    showOutput(`‚ö† Identit√† pubblica gi√† presente come "${existing.name}"`, 'warning');
                }
                
            } catch (error) {
                showOutput(`‚ùå Errore nell'aggiunta: ${error}`, 'error');
            }
        }

        function clearVerify() {
            document.getElementById('verifyHashInput').value = '';
            document.getElementById('publicIdentityName').value = '';
            document.getElementById('verifyResult').innerHTML = '';
            document.getElementById('addToIdentitiesBtn').style.display = 'none';
            currentVerification = {
                originalHash: null,
                rnsHash: null,
                type: null,
                aspects: {},
                isPublic: true
            };
        }

        function calculateAspectHash() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const aspect = document.getElementById('aspectInput').value.trim();
            if (!aspect) {
                showOutput('‚ùå Inserisci un aspect!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -H "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -H "${aspect}"`;
            }
            
            executeCommand();
        }

        async function executeCommand() {
            const command = document.getElementById('commandInput').value.trim();
            if (!command) {
                showOutput('Inserisci un comando!', 'error');
                return;
            }
            
            showOutput(`Esecuzione: ${command}`, 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(`‚úÖ Completato\n\n${data.output}`, 'success');
                } else {
                    let errorMsg = `‚ùå Errore (code: ${data.return_code})\n`;
                    if (data.error) errorMsg += `${data.error}\n`;
                    if (data.output) errorMsg += `${data.output}`;
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }
        
        function showIdentityInfo() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" --print-identity`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} --print-identity -P`;
            }
            
            executeCommand();
        }

        function announceWithCustomAspect() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const aspect = document.getElementById('announceAspect').value.trim();
            if (!aspect) {
                showOutput('‚ùå Inserisci un aspect!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -a "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -a "${aspect}"`;
            }
            
            executeCommand();
        }
        
        function announceWithAspect() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const aspect = document.getElementById('announceAspect').value.trim() || "rnstransport.probe";
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -a "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -a "${aspect}"`;
            }
            
            executeCommand();
        }

        function handleCryptoFileSelect() {
            const fileInput = document.getElementById('cryptoFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('cryptoFileStatus');
            
            if (!file) return;
            
            selectedCryptoFile = file;
            status.innerHTML = `<span class="success">‚úÖ File selezionato: ${file.name} (${file.size} bytes)</span>`;
            
            const fileName = file.name;
            
            if (fileName.endsWith('.enc')) {
                const baseName = fileName.substring(0, fileName.length - 4);
                document.getElementById('outputFileName').value = baseName;
            } else {
                document.getElementById('outputFileName').value = fileName + '.enc';
            }
        }

        async function encryptFile() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (!selectedCryptoFile) {
                showOutput('‚ùå Seleziona prima un file!', 'error');
                return;
            }
            
            let outputFile = document.getElementById('outputFileName').value.trim();
            if (!outputFile) {
                showOutput('‚ùå Inserisci un nome per il file output!', 'error');
                return;
            }
            
            showOutput(`üîí Upload e cifratura file...`, 'warning');
            
            try {
                let command = '';
                const uploadData = await uploadFileToTemp(selectedCryptoFile, 'encrypt');
                
                if (!uploadData.temp_path) {
                    throw new Error('Upload failed');
                }
                
                const tempPath = uploadData.temp_path;
                const outputDir = uploadData.output_dir;
                const outputPath = outputDir + '/' + outputFile;
                
                if (selectedIdentity.startsWith('public:')) {
                    const rnsHash = selectedIdentity.replace('public:', '');
                    command = `rnid -R -i "${rnsHash}" -e "${tempPath}" -w "${outputPath}" -f`;
                } else {
                    showOutput(`üîç Estrazione hash RNS pubblico...`, 'warning');
                    
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    
                    const hashResponse = await fetch('/api/rnid', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            command: `rnid -i ${cmdPath} --print-identity` 
                        })
                    });
                    
                    const hashData = await hashResponse.json();
                    let rnsHash = null;
                    
                    if (hashData.success && hashData.output) {
                        const match = hashData.output.match(/Loaded Identity <([0-9a-f]+)>/);
                        if (match) {
                            rnsHash = match[1];
                            showOutput(`‚úÖ Hash RNS pubblico: ${rnsHash}`, 'success');
                        }
                    }
                    
                    if (rnsHash) {
                        command = `rnid -R -i "${rnsHash}" -e "${tempPath}" -w "${outputPath}" -f`;
                    } else {
                        throw new Error('Impossibile ottenere hash RNS pubblico');
                    }
                }
                
                document.getElementById('commandInput').value = command;
                showOutput(`‚úÖ Comando pronto:\n${command}\n\nFile verr√† salvato in: ${outputPath}`, 'success');
                executeCommand();
                
                setTimeout(() => cleanupTempFile(tempPath), 10000);
                
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        async function decryptFile() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (!selectedCryptoFile) {
                showOutput('‚ùå Seleziona prima un file!', 'error');
                return;
            }
            
            let outputFile = document.getElementById('outputFileName').value.trim();
            if (!outputFile) {
                showOutput('‚ùå Inserisci un nome per il file output!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                showOutput('‚ùå Per DECIFRARE serve un\'identit√† PRIVATA', 'error');
                return;
            }
            
            showOutput(`üîì Upload e decifratura file...`, 'warning');
            
            try {
                const uploadData = await uploadFileToTemp(selectedCryptoFile, 'decrypt');
                const tempPath = uploadData.temp_path;
                const outputDir = uploadData.output_dir;
                const outputPath = outputDir + '/' + outputFile;
                
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                const command = `rnid -i ${cmdPath} -d "${tempPath}" -w "${outputPath}" -f`;
                
                document.getElementById('commandInput').value = command;
                showOutput(`‚úÖ Comando pronto:\n${command}\n\nFile verr√† salvato in: ${outputPath}`, 'success');
                executeCommand();
                
                setTimeout(() => cleanupTempFile(tempPath), 10000);
                
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        async function encryptText() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const text = document.getElementById('cryptoTextInput').value.trim();
            if (!text) {
                showOutput('‚ùå Inserisci del testo da cifrare!', 'error');
                return;
            }
            
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const cleanCommand = 'rm -f /tmp/web_input.txt /tmp/web_encrypted.enc';
            const escapedText = text.replace(/"/g, '\\"');
            const writeCommand = `echo "${escapedText}" > /tmp/web_input.txt`;
            
            let command = '';
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                command = `${cleanCommand} && ${writeCommand} && rnid -R -i "${rnsHash}" -e /tmp/web_input.txt -w /tmp/web_encrypted.enc -f`;
            } else {
                showOutput(`üîç Estrazione hash RNS pubblico...`, 'warning');
                
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                
                const hashResponse = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        command: `rnid -i ${cmdPath} --print-identity` 
                    })
                });
                
                const hashData = await hashResponse.json();
                let rnsHash = null;
                
                if (hashData.success && hashData.output) {
                    const match = hashData.output.match(/Loaded Identity <([0-9a-f]+)>/);
                    if (match) {
                        rnsHash = match[1];
                        showOutput(`‚úÖ Hash RNS pubblico: ${rnsHash}`, 'success');
                    }
                }
                
                if (rnsHash) {
                    command = `${cleanCommand} && ${writeCommand} && rnid -R -i "${rnsHash}" -e /tmp/web_input.txt -w /tmp/web_encrypted.enc -f`;
                } else {
                    showOutput('‚ùå Impossibile ottenere hash RNS pubblico', 'error');
                    return;
                }
            }
            
            const fullCommand = `${command} && base64 /tmp/web_encrypted.enc`;
            
            showOutput(`üîí Cifratura in corso...`, 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(`‚úÖ ${data.output}`, 'success');
                    
                    const outputLines = data.output.trim().split('\n');
                    let base64Lines = [];
                    let foundBase64 = false;
                    
                    for (const line of outputLines) {
                        const trimmedLine = line.trim();
                        
                        if (trimmedLine && !trimmedLine.includes(' ') && /^[A-Za-z0-9+/=]+$/.test(trimmedLine)) {
                            base64Lines.push(trimmedLine);
                            foundBase64 = true;
                        }
                        else if (foundBase64 && trimmedLine && 
                                !trimmedLine.includes('Loaded Identity') &&
                                !trimmedLine.includes('Encrypting') &&
                                !trimmedLine.includes('File') &&
                                !trimmedLine.includes('rm -f') &&
                                !trimmedLine.includes('echo') &&
                                !trimmedLine.includes('base64') &&
                                !trimmedLine.includes('rnid')) {
                            base64Lines.push(trimmedLine);
                        }
                    }
                    
                    let encryptedBase64 = base64Lines.join('');
                    
                    if (!encryptedBase64) {
                        const lines = data.output.split('\n');
                        let startCollecting = false;
                        let collectedLines = [];
                        
                        for (const line of lines) {
                            if (line.includes('base64 /tmp/web_encrypted.enc')) {
                                startCollecting = true;
                                continue;
                            }
                            
                            if (startCollecting && line.trim()) {
                                collectedLines.push(line.trim());
                            }
                        }
                        
                        encryptedBase64 = collectedLines.join('');
                    }
                    
                    encryptedBase64 = encryptedBase64.replace(/\s+/g, '');
                    
                    document.getElementById('cryptoEncryptedOutput').value = encryptedBase64;
                    document.getElementById('cryptoEncryptedResult').style.display = 'block';
                    
                    setTimeout(() => {
                        const outputField = document.getElementById('cryptoEncryptedOutput');
                        outputField.select();
                        outputField.focus();
                    }, 100);
                    
                } else {
                    let errorMsg = `‚ùå Errore (code: ${data.return_code})\n`;
                    if (data.error) errorMsg += `${data.error}\n`;
                    if (data.output) errorMsg += `${data.output}`;
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        async function decryptText() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const text = document.getElementById('cryptoTextInput').value.trim();
            if (!text) {
                showOutput('‚ùå Inserisci dati cifrati!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                showOutput('‚ùå Per DECIFRARE serve un\'identit√† PRIVATA', 'error');
                return;
            }
            
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const hasSpaces = selectedIdentity.includes(' ');
            const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
            const cleanInput = text.replace(/\s+/g, '');
            
            const fullCommand = `rm -f /tmp/web_encrypted.enc /tmp/web_decrypted.txt && ` +
                               `echo "${cleanInput}" | base64 -d > /tmp/web_encrypted.enc && ` +
                               `rnid -i ${cmdPath} -d /tmp/web_encrypted.enc -w /tmp/web_decrypted.txt -f && ` +
                               `cat /tmp/web_decrypted.txt && rm -f /tmp/web_encrypted.enc /tmp/web_decrypted.txt`;
            
            showOutput(`üîì Decifratura in corso...`, 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const output = data.output;
                    
                    showOutput(`‚úÖ ${output}`, 'success');
                    
                    const lines = output.split('\n');
                    let decryptedLines = [];
                    
                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        
                        if (trimmedLine && 
                            !trimmedLine.includes('Loaded Identity') &&
                            !trimmedLine.includes('Decrypting') &&
                            !trimmedLine.includes('File') &&
                            !trimmedLine.includes('rm -f') &&
                            !trimmedLine.includes('echo') &&
                            !trimmedLine.includes('base64') &&
                            !trimmedLine.includes('rnid -i') &&
                            !trimmedLine.includes('cat /tmp/web_decrypted.txt') &&
                            !trimmedLine.startsWith('[') &&
                            !trimmedLine.includes('/tmp/')) {
                            decryptedLines.push(trimmedLine);
                        }
                    }
                    
                    let decryptedText = decryptedLines.join('\n');
                    
                    if (!decryptedText) {
                        for (let i = lines.length - 1; i >= 0; i--) {
                            if (lines[i].trim()) {
                                decryptedText = lines[i].trim();
                                break;
                            }
                        }
                    }
                    
                    document.getElementById('cryptoDecryptedOutput').value = decryptedText;
                    document.getElementById('cryptoDecryptedResult').style.display = 'block';
                    
                    setTimeout(() => {
                        const outputField = document.getElementById('cryptoDecryptedOutput');
                        outputField.select();
                        outputField.focus();
                    }, 100);
                    
                } else {
                    let errorMsg = `‚ùå Errore (code: ${data.return_code})\n`;
                    if (data.error) errorMsg += `${data.error}\n`;
                    if (data.output) errorMsg += `${data.output}`;
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        function handleSignFileSelect() {
            const fileInput = document.getElementById('signFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('signFileStatus');
            
            if (!file) return;
            
            selectedSignFile = file;
            status.innerHTML = `<span class="success">‚úÖ File selezionato: ${file.name} (${file.size} bytes)</span>`;
            
            const sigFileName = file.name + '.rsg';
            document.getElementById('signatureFileName').value = sigFileName;
        }

        function handleSigFileSelect() {
            const fileInput = document.getElementById('sigFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('sigFileStatus');
            
            if (!file) return;
            
            selectedSigFileForVerification = file;
            status.innerHTML = `<span class="success">‚úÖ File firma selezionato: ${file.name}</span>`;
        }

        async function signFile() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (!selectedSignFile) {
                showOutput('‚ùå Seleziona prima un file da firmare!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                showOutput('‚ùå Per firmare serve un\'identit√† PRIVATA', 'error');
                return;
            }
            
            showOutput(`‚úçÔ∏è Firma file: ${selectedSignFile.name}...`, 'warning');
            
            try {
                const formData = new FormData();
                formData.append('file', selectedSignFile);
                formData.append('purpose', 'sign');
                
                const response = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Upload fallito: ${response.status}`);
                }
                
                const uploadData = await response.json();
                
                if (!uploadData.success || !uploadData.temp_path) {
                    throw new Error(uploadData.error || 'Upload fallito');
                }
                
                const tempPath = uploadData.temp_path;
                const downloadsDir = uploadData.output_dir;
                const fileName = selectedSignFile.name;
                
                const originalInDownloads = downloadsDir + '/' + fileName;
                const sigFileName = document.getElementById('signatureFileName').value.trim() || fileName + '.rsg';
                const sigInDownloads = downloadsDir + '/' + sigFileName;
                
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                const command = `cp "${tempPath}" "${originalInDownloads}" && rnid -i ${cmdPath} -s "${originalInDownloads}" -w "${sigInDownloads}" -f`;
                
                document.getElementById('commandInput').value = command;
                showOutput(`‚úÖ Comando pronto:\n${command}\n\nFile originale: ${originalInDownloads}\nFirma: ${sigInDownloads}`, 'success');
                
                executeCommand();
                
                setTimeout(() => {
                    fetch('/api/cleanup/temp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ temp_path: tempPath })
                    }).catch(e => console.warn('Cleanup failed:', e));
                }, 5000);
                
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        async function verifySignature() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (!selectedSigFileForVerification) {
                showOutput('‚ùå Seleziona prima il file firma .rsg!', 'error');
                return;
            }
            
            const fileName = selectedSigFileForVerification.name;
            
            if (!fileName.toLowerCase().endsWith('.rsg')) {
                showOutput(`‚ùå Il file deve essere una firma (.rsg)!\nRicevuto: ${fileName}`, 'error');
                return;
            }
            
            showOutput(`üîç Verifica firma: ${fileName}...`, 'warning');
            
            try {
                const formData = new FormData();
                formData.append('file', selectedSigFileForVerification);
                formData.append('purpose', 'verify');
                
                const uploadResponse = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error(`Upload fallito: ${uploadResponse.status}`);
                }
                
                const uploadData = await uploadResponse.json();
                
                if (!uploadData.success || !uploadData.temp_path) {
                    throw new Error(uploadData.error || 'Upload fallito');
                }
                
                const tempPath = uploadData.temp_path;
                const downloadsDir = uploadData.output_dir;
                const sigFileName = selectedSigFileForVerification.name;
                const sigInDownloads = downloadsDir + '/' + sigFileName;
                
                const copyCommand = `cp "${tempPath}" "${sigInDownloads}"`;
                
                let verifyCommand;
                if (selectedIdentity.startsWith('public:')) {
                    const rnsHash = selectedIdentity.replace('public:', '');
                    verifyCommand = `rnid -R -i "${rnsHash}" -V "${sigInDownloads}"`;
                } else {
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    verifyCommand = `rnid -i ${cmdPath} -V "${sigInDownloads}"`;
                }
                
                const fullCommand = `${copyCommand} && ${verifyCommand}`;
                
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                
                const verifySection = document.getElementById('verifyResultSection');
                const verifyOutput = document.getElementById('verifyResultOutput');
                
                if (verifySection && verifyOutput) {
                    verifySection.style.display = 'block';
                    
                    if (data.success) {
                        const output = data.output || '';
                        
                        if (output.includes('is valid') && !output.includes('is invalid')) {
                            verifyOutput.value = `‚úÖ FIRMA VALIDA\n\n${output}`;
                            showOutput(`‚úÖ ${sigFileName}: FIRMA VALIDA`, 'success');
                        } else if (output.includes('is invalid')) {
                            verifyOutput.value = `‚ùå FIRMA NON VALIDA\n\n${output}`;
                            showOutput(`‚ùå ${sigFileName}: FIRMA NON VALIDA`, 'error');
                        } else {
                            verifyOutput.value = `‚ö† RISULTATO VERIFICA\n\n${output}`;
                            showOutput(`‚ö† ${sigFileName}: Verifica completata`, 'warning');
                        }
                    } else {
                        verifyOutput.value = `‚ùå ERRORE\n\n${data.error || data.output || 'Errore sconosciuto'}`;
                        showOutput(`‚ùå Errore: ${data.error || data.output}`, 'error');
                    }
                }
                
                setTimeout(() => {
                    fetch('/api/cleanup/temp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ temp_path: tempPath })
                    }).catch(e => console.warn('Cleanup ignorato:', e));
                }, 3000);
                
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        function copyVerifyResult() {
            const output = document.getElementById('verifyResultOutput');
            if (!output || !output.value.trim()) {
                showOutput('‚ùå Nessun risultato da copiare!', 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput('‚úÖ Risultato copiato!', 'success');
            } catch (err) {
                showOutput('‚ùå Errore nella copia: ' + err, 'error');
            }
        }

        async function uploadFileToTemp(file, purpose = 'crypto') {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('purpose', purpose);
            
            try {
                const response = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    return {
                        success: true,
                        temp_path: data.temp_path,
                        output_dir: data.output_dir,
                        original_name: data.original_name
                    };
                } else {
                    return {
                        success: false,
                        error: data.error || 'Upload failed'
                    };
                }
            } catch (error) {
                return {
                    success: false,
                    error: `Upload error: ${error.message}`
                };
            }
        }

        async function cleanupTempFile(tempPath) {
            try {
                await fetch('/api/cleanup/temp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ temp_path: tempPath })
                });
            } catch (error) {
                console.warn('Cleanup failed:', error);
            }
        }

        function copyEncryptedResult() {
            const output = document.getElementById('cryptoEncryptedOutput');
            if (!output || !output.value.trim()) {
                showOutput('‚ùå Nessun testo cifrato da copiare!', 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput('‚úÖ Testo cifrato copiato!', 'success');
            } catch (err) {
                showOutput('‚ùå Errore nella copia: ' + err, 'error');
            }
        }

        function copyDecryptedResult() {
            const output = document.getElementById('cryptoDecryptedOutput');
            if (!output || !output.value.trim()) {
                showOutput('‚ùå Nessun testo decifrato da copiare!', 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput('‚úÖ Testo decifrato copiato!', 'success');
            } catch (err) {
                showOutput('‚ùå Errore nella copia: ' + err, 'error');
            }
        }

        function clearCryptoText() {
            document.getElementById('cryptoTextInput').value = '';
            document.getElementById('cryptoEncryptedOutput').value = '';
            document.getElementById('cryptoDecryptedOutput').value = '';
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const cleanCommand = 'rm -f /tmp/web_input.txt /tmp/web_encrypted.enc /tmp/web_decrypted.txt';
            
            fetch('/api/rnid', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command: cleanCommand })
            }).catch(() => {});
            
            showOutput('üóë Testo e risultati crittografia puliti', 'warning');
        }
        
        function showOutput(message, type = '') {
            const output = document.getElementById('output');
            
            const escapedMessage = message
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            const className = type ? ` class="${type}"` : '';
            output.innerHTML = `<pre style="margin:0; padding:0; font-family:inherit; font-size:inherit; white-space:pre-wrap; word-wrap:break-word;"${className}>${escapedMessage}</pre>`;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearCommand() {
            document.getElementById('commandInput').value = '';
        }
        
        // NIENTE CARICAMENTO AUTOMATICO!
        window.onload = function() {
            document.getElementById('commandInput').value = 'rnid -h';
            setTimeout(() => executeCommand(), 500);
            
            // Mostra messaggio che invita a premere Carica
            const list = document.getElementById('identitiesList');
            list.innerHTML = '<div class="warning"> Premi "Carica" per visualizzare le identit√†</div>';
        };
        
        document.addEventListener('touchstart', function(event) {
            if (event.touches.length > 1) {
                event.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>