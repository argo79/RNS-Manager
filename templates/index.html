<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RNID Identity Manager</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
        :root {
            --bg-color: #0a0a0a;
            --text-color: #00ff00;
            --border-color: #008800;
            --accent-color: #00aa00;
            --panel-bg: #111111;
            --hover-bg: #1a1a1a;
            --mobile-width: 480px;
            --desktop-width: 1400px;
        }
        
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: var(--bg-color);
            color: var(--text-color);
            line-height: 1.4;
            font-size: 14px;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        
        .container {
            width: 100%;
            max-width: var(--mobile-width);
            margin: 0 auto;
        }
        
        header {
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
            text-align: center;
            position: sticky;
            top: 0;
            background: var(--bg-color);
            z-index: 100;
            padding-top: 5px;
        }
        
        h1 { 
            font-size: 18px; 
            margin-bottom: 3px; 
            word-break: break-word;
        }
        
        h2 { 
            font-size: 15px; 
            color: var(--accent-color);
            margin: 12px 0 8px 0;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .section {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            padding: 12px;
            margin-bottom: 12px;
            border-radius: 5px;
            width: 100%;
            height: 100%;
        }
        
        .row {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 12px;
            width: 100%;
        }
        
        .col {
            width: 100%;
        }
        
        /* Desktop: 3 colonne affiancate */
        @media (min-width: 1024px) {
            .container {
                max-width: var(--desktop-width);
            }
            
            .row {
                flex-direction: row;
                flex-wrap: nowrap;
                gap: 15px;
                align-items: stretch;
            }
            
            .col {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-width: 0;
            }
            
            .section {
                margin-bottom: 0;
                flex: 1;
                display: flex;
                flex-direction: column;
            }
            
            .identities-list {
                flex: 1;
                min-height: 400px;
            }
            
            .output {
                flex: 1;
                min-height: 300px;
            }
            
            h1 { font-size: 20px; }
            h2 { font-size: 16px; }
            
            button {
                padding: 8px 12px;
                font-size: 13px;
            }
            
            .aspect-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .aspect-btn {
                font-size: 11px;
                padding: 8px;
            }
        }
        
        .identities-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
            -webkit-overflow-scrolling: touch;
        }
        
        .identity-item {
            padding: 8px;
            border-bottom: 1px solid #222;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            min-height: 60px;
        }
        
        .identity-item:hover {
            background: var(--hover-bg);
        }
        
        .identity-item.selected {
            background: #001a00;
            border-left: 3px solid var(--accent-color);
        }
        
        .identity-name {
            font-weight: bold;
            color: var(--accent-color);
            font-size: 13px;
            word-break: break-all;
        }
        
        .identity-info {
            font-size: 11px;
            color: #888;
            line-height: 1.3;
        }
        
        .identity-badge {
            font-size: 10px;
            padding: 2px 4px;
            background: #333;
            border-radius: 3px;
            white-space: nowrap;
            margin-left: 5px;
            flex-shrink: 0;
        }
        
        .command-area textarea {
            width: 100%;
            height: 70px;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 8px;
            font-family: inherit;
            font-size: 11px;
            resize: vertical;
            border-radius: 3px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin: 8px 0;
        }
        
        button {
            background: var(--accent-color);
            color: black;
            border: none;
            padding: 8px 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            font-weight: bold;
            border-radius: 4px;
            flex: 1;
            min-width: 70px;
            text-align: center;
            touch-action: manipulation;
        }
        
        button:hover, button:active {
            background: #00cc00;
        }
        
        button.secondary {
            background: #333;
            color: var(--text-color);
        }
        
        button.secondary:hover, button.secondary:active {
            background: #444;
        }
        
        button.small {
            padding: 4px 6px;
            font-size: 10px;
            min-width: 60px;
        }
        
        .output {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            padding: 10px;
            min-height: 150px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: inherit;
            font-size: 11px;
            line-height: 1.3;
            border-radius: 3px;
            -webkit-overflow-scrolling: touch;
        }
        
        .success { color: #00ff00; }
        .error { color: #ff0000; }
        .warning { color: #ffff00; }
        
        .form-group {
            margin-bottom: 8px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 11px;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 6px;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            font-family: inherit;
            font-size: 12px;
            border-radius: 3px;
        }
        
        .form-group textarea {
            height: 50px;
            resize: vertical;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: block;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 33%;
            height: 100%;
            cursor: pointer;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 12px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .tab {
            padding: 6px 14px;
            cursor: pointer;
            border: 1px solid transparent;
            margin-right: 4px;
            margin-bottom: 1px;
            white-space: nowrap;
            font-size: 12px;
            flex-shrink: 0;
        }
        
        .tab:hover, .tab:active {
            background: var(--hover-bg);
        }
        
        .tab.active {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-bottom-color: var(--panel-bg);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .aspect-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        
        .aspect-input-group input {
            flex: 1;
            min-width: 150px;
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 6px;
            font-family: inherit;
            font-size: 12px;
            border-radius: 3px;
        }
        
        .aspect-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-top: 8px;
        }
        
        .aspect-btn {
            background: #222;
            color: #0f0;
            border: 1px solid #333;
            padding: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 10px;
            font-family: monospace;
            border-radius: 3px;
            word-break: break-all;
        }
        
        .aspect-btn:hover, .aspect-btn:active {
            background: #333;
        }
        
        .export-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        
        .copy-btn {
            background: #333;
            color: #0f0;
            border: 1px solid #444;
            padding: 6px 10px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            border-radius: 3px;
            flex: 1;
            min-width: 80px;
        }
        
        .copy-btn:hover, .copy-btn:active {
            background: #444;
        }
        
        /* Pulsante copia pi√π piccolo per crittografia */
        .crypto-copy-btn {
            background: #333;
            color: #0f0;
            border: 1px solid #444;
            padding: 2px 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 9px;
            border-radius: 2px;
            margin-left: 5px;
        }
        
        .crypto-copy-btn:hover, .crypto-copy-btn:active {
            background: #444;
        }
        
        @media (max-width: 480px) {
            body {
                padding: 5px;
                font-size: 13px;
            }
            
            .container {
                padding: 0 5px;
            }
            
            h1 {
                font-size: 16px;
            }
            
            h2 {
                font-size: 14px;
            }
            
            .section {
                padding: 10px;
            }
            
            button {
                padding: 7px 8px;
                font-size: 11px;
                min-width: 60px;
            }
            
            .aspect-buttons {
                grid-template-columns: 1fr;
            }
            
            .aspect-btn {
                font-size: 9px;
                padding: 5px;
            }
            
            .identity-item {
                flex-direction: column;
                gap: 4px;
            }
        }
        
        @media (min-width: 768px) and (max-width: 1023px) {
            .container {
                max-width: 768px;
            }
            
            .row {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .col {
                flex: 1 1 calc(50% - 15px);
                min-width: 300px;
            }
        }
        
        @media (min-width: 1024px) {
            .identities-list {
                max-height: 450px;
            }
            
            .output {
                max-height: 400px;
            }
            
            .command-area textarea {
                height: 100px;
                font-size: 12px;
            }
            
            .identity-name {
                font-size: 14px;
            }
            
            .identity-info {
                font-size: 12px;
            }
        }
        
        @media (orientation: portrait) and (max-height: 700px) {
            .identities-list {
                max-height: 200px;
            }
            
            .output {
                max-height: 200px;
                min-height: 120px;
            }
        }
        
        @media (orientation: landscape) and (max-height: 500px) and (max-width: 1023px) {
            .container {
                max-width: 100%;
            }
            
            .row {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .col {
                flex: 1;
                min-width: 300px;
            }
            
            .identities-list {
                max-height: 180px;
            }
            
            .output {
                max-height: 180px;
            }
        }
        
        @media (hover: none) and (pointer: coarse) {
            button, .tab, .aspect-btn, .identity-item {
                min-height: 44px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .identity-item {
                min-height: 50px;
            }
            
            input, select, textarea {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>RETICULUM IDENTITY MANAGER GUI 1.0.0</h1>
            <div>Gestione identit√† Reticulum</div>
        </header>
        
        <div class="row">
            <!-- COLONNA 1: Gestione Identit√† -->
            <div class="col">
                <div class="section">
                    <h2>IDENTIT√Ä DISPONIBILI</h2>
                    <div class="button-group">
                        <button onclick="loadIdentities()">üîÑ Ricarica</button>
                        <button class="secondary" onclick="scanAllStorage()">üîç Cerca</button>
                    </div>
                    
                    <div id="identitiesList" class="identities-list">
                        <div class="warning">Caricamento identit√†...</div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="tabs">
                        <div class="tab active" onclick="showTab('import-tab')">IMPORT</div>
                        <div class="tab" onclick="showTab('export-tab')">EXPORT</div>
                        <div class="tab" onclick="showTab('generate-tab')">GENERA</div>
                    </div>
                    
                    <!-- IMPORT TAB -->
                    <div id="import-tab" class="tab-content active">
                        <div class="form-group">
                            <label>Importa da file (64 bytes):</label>
                            <div class="file-input-wrapper">
                                <button>üìÅ Scegli file identit√†</button>
                                <input type="file" id="fileImport" accept="*" onchange="handleFileImport()">
                            </div>
                            <!-- Aggiungi campo per il nome -->
                            <div class="form-group" style="margin-top: 8px;">
                                <label>Nome identit√† (opzionale):</label>
                                <input type="text" id="importFileName" 
                                       placeholder="es: nodo_remoto, server_backup, ecc."
                                       style="font-family: inherit; font-size: 11px; width: 100%;">
                                <div style="font-size: 10px; color: #888; margin-top: 2px;">
                                    Se lasciato vuoto, verr√† generato automaticamente
                                </div>
                            </div>
                            <div id="fileImportStatus" style="font-size:10px; margin-top:4px;"></div>
                        </div>
                        
                        <div class="form-group">
                            <label>Oppure importa da dati:</label>
                            <div class="button-group">
                                <button class="secondary" onclick="importFromData('hex')">HEX</button>
                                <button class="secondary" onclick="importFromData('base32')">Base32</button>
                                <button class="secondary" onclick="importFromData('base64')">Base64</button>
                            </div>
                            <div class="form-group" style="margin-top: 8px;">
                                <label>Nome identit√† (opzionale):</label>
                                <input type="text" id="importDataName" 
                                       placeholder="es: nodo_remoto, server_backup, ecc."
                                       style="font-family: inherit; font-size: 11px; width: 100%;">
                            </div>
                            <textarea id="importData" placeholder="Incolla i dati identit√† qui..."></textarea>
                        </div>
                    </div>

                    <!-- EXPORT TAB -->
                    <div id="export-tab" class="tab-content">
                        <div class="form-group">
                            <label>Esporta identit√† selezionata:</label>
                            <div class="button-group">
                                <button onclick="exportIdentity('hex')">HEX</button>
                                <button onclick="exportIdentity('base32')">Base32</button>
                                <button onclick="exportIdentity('base64')">Base64</button>
                            </div>
                            <div id="exportResult" style="margin-top:8px;"></div>
                        </div>
                    </div>
                    
                    <!-- GENERATE TAB -->
                    <div id="generate-tab" class="tab-content">
                        <div class="form-group">
                            <label>Nome nuova identit√†:</label>
                            <input type="text" id="newIdentityName" placeholder="es: New_identity" value="New_identity">
                            <button onclick="generateNewIdentity()">Genera Identit√†</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- COLONNA 2: Operazioni & Analytics -->
            <div class="col">                
                
                <div class="section">
                    <h2>VERIFICA & ANALISI HASH</h2>
                    <div class="form-group">
                        <label>Inserisci hash (32 bytes HEX):</label>
                        <input type="text" id="verifyHashInput" 
                               placeholder="Es: bd96b8a833b14e64d57e781c3e7e4836"
                               style="font-family: monospace; font-size: 11px; width: 100%;">
                        
                        <label style="margin-top: 8px;">Nome identit√† (opzionale):</label>
                        <input type="text" id="publicIdentityName" 
                               placeholder="Es: remote node"
                               style="font-family: inherit; font-size: 11px; width: 100%;">
                        
                        <div class="button-group">
                            <button onclick="verifyHash()">üîç Analizza</button>
                            <button class="secondary" onclick="clearVerify()">üóë Pulisci</button>
                            <button class="secondary" onclick="addToPublicIdentities()" id="addToIdentitiesBtn" style="display:none;">‚ûï Aggiungi alle Pubbliche</button>
                        </div>
                    </div>
                    
                    <div id="verifyResult" style="margin-top: 10px; font-size: 11px; max-height: 300px; overflow-y: auto; padding: 8px; background: #111; border: 1px solid #333; border-radius: 3px;"></div>
                </div>

                <div class="section">
                    <h2>CALCOLO HASH ASPECT</h2>
                    <div class="aspect-input-group">
                        <input type="text" id="aspectInput" placeholder="Inserisci aspect RNS" value="rnstransport.probe">
                        <button onclick="calculateAspectHash()">üî¢ Calcola</button>
                    </div>
                    
                    <div class="aspect-buttons">
                        <button class="aspect-btn" onclick="setAspect('rnstransport.probe')">rnstransport.probe</button>
                        <button class="aspect-btn" onclick="setAspect('lxmf.delivery')">lxmf.delivery</button>
                        <button class="aspect-btn" onclick="setAspect('nomadnetwork.node')">nomadnetwork.node</button>
                        <button class="aspect-btn" onclick="setAspect('lxmf.propagation')">lxmf.propagation</button>
                        <button class="aspect-btn" onclick="setAspect('call.audio')">call.audio</button>
                        <button class="aspect-btn" onclick="setAspect('lxst.telephony')">lxst.telephony</button>
                    </div>
                </div>

                <!-- SEZIONE CIFRATURA & DECIFRATURA -->
                <div class="section">
                    <h2>üîê CIFRATURA & DECIFRATURA</h2>
                    
                    <div class="tabs" id="crypto-tabs">
                        <div class="tab active" onclick="showCryptoTab('crypto-file-tab')">üìÅ File</div>
                        <div class="tab" onclick="showCryptoTab('crypto-text-tab')">üìù Testo</div>
                    </div>
                    
                    <!-- TAB FILE -->
                    <div id="crypto-file-tab" class="tab-content active">
                        <div class="form-group">
                            <label>File input:</label>
                            <div class="file-input-wrapper">
                                <button>üìÅ Scegli file</button>
                                <input type="file" id="cryptoFileInput" accept="*" onchange="handleCryptoFileSelect()">
                            </div>
                            <div id="cryptoFileStatus" style="font-size:10px; margin-top:4px;"></div>
                        </div>
                        
                        <div class="form-group">
                            <label>File output:</label>
                            <input type="text" id="outputFileName" 
                                   placeholder="es: output.txt.enc o output.txt"
                                   style="font-family: monospace; font-size: 11px;">
                        </div>
                        
                        <div class="button-group">
                            <button onclick="encryptFile()">üîí Cifra File</button>
                            <button onclick="decryptFile()">üîì Decifra File</button>
                        </div>
                    </div>
                    
                    <!-- TAB TESTO -->
                    <div id="crypto-text-tab" class="tab-content">
                        <div class="form-group">
                            <label>Testo da cifrare/decifrare:</label>
                            <textarea id="cryptoTextInput" 
                                     placeholder="Incolla il testo qui..."
                                     style="height: 80px; font-family: monospace; font-size: 11px;"></textarea>
                        </div>
                        
                        <div class="button-group">
                            <button onclick="encryptText()">üîí Cifra Testo</button>
                            <button onclick="decryptText()">üîì Decifra Testo</button>
                            <button class="secondary" onclick="clearCryptoText()">üóë Pulisci</button>
                        </div>
                        
                        <!-- RISULTATO CIFRATO -->
                        <div id="cryptoEncryptedResult" style="margin-top: 10px; display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <label style="margin: 0; font-size: 11px;">Testo cifrato:</label>
                                <button class="crypto-copy-btn" onclick="copyEncryptedResult()">
                                    üìã Copia
                                </button>
                            </div>
                            <textarea id="cryptoEncryptedOutput" 
                                     readonly
                                     style="width:100%; height: 60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                     onclick="this.select()"></textarea>
                        </div>
                        
                        <!-- RISULTATO DECIFRATO -->
                        <div id="cryptoDecryptedResult" style="margin-top: 10px; display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                                <label style="margin: 0; font-size: 11px;">Testo decifrato:</label>
                                <button class="crypto-copy-btn" onclick="copyDecryptedResult()">
                                    üìã Copia
                                </button>
                            </div>
                            <textarea id="cryptoDecryptedOutput" 
                                     readonly
                                     style="width:100%; height: 60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                     onclick="this.select()"></textarea>
                        </div>
                    </div>
                </div>

                <!-- SEZIONE FIRMA & VERIFICA FIRMA -->
                <div class="section">
                    <h2>‚úçÔ∏è FIRMA & VERIFICA FIRMA</h2>
                    
                    <div class="form-group">
                        <label>File da firmare/verificare:</label>
                        <div class="file-input-wrapper">
                            <button>üìÅ Scegli file</button>
                            <input type="file" id="signFileInput" accept="*" onchange="handleSignFileSelect()">
                        </div>
                        <div id="signFileStatus" style="font-size:10px; margin-top:4px;"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>File firma .rsg (solo per verifica):</label>
                        <div class="file-input-wrapper">
                            <button>üìÅ Scegli file .rsg</button>
                            <input type="file" id="sigFileInput" accept=".rsg" onchange="handleSigFileSelect()">
                        </div>
                        <div id="sigFileStatus" style="font-size:10px; margin-top:4px;"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>File firma output (.rsg):</label>
                        <input type="text" id="signatureFileName" 
                               placeholder="es: documento.rsg"
                               style="font-family: monospace; font-size: 11px; width: 100%;"
                               value="">
                    </div>
                    
                    <div class="button-group">
                        <button onclick="signFile()">‚úçÔ∏è Firma File</button>
                        <button onclick="verifySignature()">‚úÖ Verifica Firma</button>
                    </div>
                    
                    <!-- RISULTATO VERIFICA -->
                    <div id="verifyResultSection" style="margin-top: 10px; display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <label style="margin: 0; font-size: 11px;">Risultato verifica:</label>
                            <button class="crypto-copy-btn" onclick="copyVerifyResult()">
                                üìã Copia
                            </button>
                        </div>
                        <textarea id="verifyResultOutput" 
                                 readonly
                                 style="width:100%; height: 80px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: none;"
                                 onclick="this.select()"></textarea>
                    </div>
                </div>
            </div>
            
            <!-- COLONNA 3: Interazione & Output -->
            <div class="col">
                <div class="section">
                    <h2>INFORMAZIONI IDENTIT√Ä</h2>
                    <div class="button-group">
                        <button class="secondary" onclick="showIdentityInfo()">‚Ñπ Info Identit√†</button>
                        <button class="secondary" onclick="announceWithAspect()">üì¢ Annuncia</button>
                    </div>
                    
                    <div class="aspect-input-group" style="margin-top: 10px;">
                        <input type="text" id="announceAspect" placeholder="Aspect da annunciare" value="rnstransport.probe">
                        <button class="secondary" onclick="announceWithCustomAspect()">üì¢ Annuncia Custom</button>
                    </div>
                </div>
                
                <!-- SEZIONE COMANDI RNID -->
                <div class="section">
                    <h2>COMANDI RNID</h2>
                    <div class="command-area">
                        <textarea id="commandInput">rnid -h</textarea>
                        <div class="button-group">
                            <button onclick="executeCommand()">‚ñ∂ Esegui</button>
                            <button class="secondary" onclick="clearCommand()">üóë Pulisci</button>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h2>OUTPUT</h2>
                    <div id="output" class="output"></div>
                </div>
                
                <div class="section">
                    <h2>INFORMAZIONI</h2>
                    <div style="font-size: 11px; color: #888; line-height: 1.3;">
                        <div style="margin-bottom: 5px;">
                            <strong>Formati supportati:</strong>
                        </div>
                        <div style="margin-bottom: 3px;">‚Ä¢ <strong>HEX</strong>: 128 caratteri</div>
                        <div style="margin-bottom: 3px;">‚Ä¢ <strong>BASE32</strong>: maiuscolo, con '='</div>
                        <div style="margin-bottom: 3px;">‚Ä¢ <strong>BASE64</strong>: standard, con '=='</div>
                        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333;">
                            <strong>Aspects RNS:</strong> rnstransport.probe, lxmf.delivery, nomadnetwork.node, lxmf.propagation, call.audio, lxst.telephony
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedIdentity = null;
        let lastExportedData = null;
        let selectedSigFileForVerification = null;
        let selectedCryptoFile = null;
        let selectedSignFile = null;

        // Tab management
        function showTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }
        
        function showCryptoTab(tabId) {
            document.querySelectorAll('#crypto-tabs .tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('#crypto-tabs ~ .tab-content, #crypto-tabs + .tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
        }
        
        // Funzione per impostare aspect
        function setAspect(aspect) {
            document.getElementById('aspectInput').value = aspect;
            document.getElementById('announceAspect').value = aspect;
            if (selectedIdentity) {
                if (selectedIdentity.startsWith('public:')) {
                    // Identit√† pubblica: usa -R
                    const rnsHash = selectedIdentity.replace('public:', '');
                    document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -H "${aspect}"`;
                } else {
                    // Identit√† normale (privata)
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    document.getElementById('commandInput').value = `rnid -i ${cmdPath} -H "${aspect}"`;
                }
            }
        }
        
        // Load identities
        async function loadIdentities() {
            const list = document.getElementById('identitiesList');
            list.innerHTML = '<div class="warning">Caricamento...</div>';
            
            try {
                // 1. Carica identit√† dal backend
                const response = await fetch('/api/identities/list');
                const backendData = await response.json();
                const backendIdentities = backendData.identities || [];
                
                // 2. Carica identit√† pubbliche da localStorage
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                
                if (backendIdentities.length === 0 && publicIdentities.length === 0) {
                    list.innerHTML = '<div class="warning">Nessuna identit√† trovata</div>';
                    return;
                }
                
                let html = '';
                
                // 3. Mostra identit√† dal backend
                backendIdentities.forEach(identity => {
                    html += renderIdentityItem(identity, false);
                });
                
                // 4. Mostra identit√† pubbliche da localStorage
                publicIdentities.forEach(identity => {
                    identity.isPublic = true;
                    html += renderIdentityItem(identity, true);
                });
                
                list.innerHTML = html;
                
            } catch (error) {
                console.error('Errore loadIdentities:', error);
                list.innerHTML = `<div class="error">Errore: ${error}</div>`;
            }
        }

        // Funzione helper per renderizzare un'identit√†
        function renderIdentityItem(identity, isPublic = false) {
            const validClass = isPublic ? 'success' : (identity.valid ? 'success' : 'warning');
            
            let sizeInfo = '';
            if (identity.size) {
                sizeInfo = identity.size === 64 ? '64 bytes ‚úì' : `${identity.size} bytes`;
            } else {
                sizeInfo = isPublic ? '32 bytes (pubblica)' : '? bytes';
            }
            
            const name = identity.name || (isPublic ? `public_${identity.rns_hash?.substring(0, 8)}` : 'unknown');
            const app = identity.app || (isPublic ? 'public' : 'unknown');
            
            let hashInfo = '';
            const rnsHash = identity.rns_hash || identity.rnsHash;
            if (rnsHash) {
                const shortHash = rnsHash.length > 32 ? 
                    rnsHash.substring(0, 32) + '...' : rnsHash;
                hashInfo = `<div style="font-size: 10px; color: #0ff; font-family: monospace; margin-top: 2px;">
                            RNS: ${shortHash}
                           </div>`;
            }
            
            let aspectInfo = '';
            const rnsAspects = ['rnstransport.probe', 'lxmf.delivery', 'nomadnetwork.node', 'lxmf.propagation', 'call.audio', 'lxst.telephony'];
            
            const aspectHashes = identity.aspect_hashes || identity.aspects || {};
            
            rnsAspects.forEach(aspect => {
                if (aspectHashes[aspect]) {
                    const hash = aspectHashes[aspect];
                    const shortHash = hash.length > 32 ? hash.substring(0, 32) + '...' : hash;
                    aspectInfo += `<div style="font-size: 9px; color: ${isPublic ? '#8f8' : '#888'}; margin-top: 1px;">
                                 ${aspect.split('.')[0]}: ${shortHash}
                                 </div>`;
                }
            });
            
            let deleteButton = '';
            if (isPublic && rnsHash) {
                deleteButton = `<button onclick="event.stopPropagation(); removePublicIdentity('${rnsHash}')" 
                                  style="background: #f44; color: white; border: none; padding: 2px 5px; font-size: 9px; border-radius: 2px; margin-left: 5px; cursor: pointer; vertical-align: middle;">
                                  ‚úï
                               </button>`;
            }
            
            return `
                <div class="identity-item" onclick="${isPublic ? `selectPublicIdentity('${rnsHash}', this)` : `selectIdentity('${identity.path}', this)`}">
                    <div style="flex: 1;">
                        <div class="identity-name">${name} ${isPublic ? 'üåê' : 'üîë'} ${deleteButton}</div>
                        <div class="identity-info">
                            ${sizeInfo} ‚Ä¢ ${app}
                            ${hashInfo}
                            ${aspectInfo}
                        </div>
                    </div>
                    <span class="identity-badge ${validClass}">
                        ${isPublic ? 'PUBBLICA' : (identity.valid ? 'PRIVATA' : 'VERIF')}
                    </span>
                </div>
            `;
        }

        // Funzione per rimuovere identit√† pubblica
        function removePublicIdentity(rnsHash) {
            if (!confirm('Sei sicuro di voler rimuovere questa identit√† pubblica?')) {
                return;
            }
            
            try {
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                const filteredIdentities = publicIdentities.filter(id => id.rns_hash !== rnsHash);
                
                localStorage.setItem('rns_public_identities', JSON.stringify(filteredIdentities));
                
                showOutput(`‚úÖ Identit√† pubblica rimossa`, 'success');
                loadIdentities();
            } catch (error) {
                showOutput(`‚ùå Errore nella rimozione: ${error}`, 'error');
            }
        }

        function selectPublicIdentity(rnsHash, element) {
            document.querySelectorAll('.identity-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            element.classList.add('selected');
            selectedIdentity = `public:${rnsHash}`;
            
            document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" --print-identity`;
            
            showOutput(`‚úÖ Selezionata identit√† pubblica: ${rnsHash}`, 'success');
        }
        
        // Export con pulsanti copia
        async function exportIdentity(format) {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            showOutput(`Esportazione in ${format}...`, 'warning');
            
            try {
                const response = await fetch('/api/identities/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: selectedIdentity, format })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    lastExportedData = { format: format, data: data.data };
                    
                    const output = document.getElementById('exportResult');
                    output.innerHTML = `
                        <div style="margin-bottom: 8px;">
                            <span class="success">‚úÖ Esportato in ${format.toUpperCase()}</span>
                        </div>
                        
                        <div class="export-buttons">
                            <button class="copy-btn" onclick="copyExportedData()">üìã Copia ${format.toUpperCase()}</button>
                        </div>
                        
                        <textarea id="exportedData" readonly 
                            style="width:100%; height:60px; background:#000; color:#0f0; border:1px solid #333; padding:8px; font-family:monospace; font-size: 11px; resize: vertical;">
${data.data}
                        </textarea>
                        
                        <div style="margin-top:8px; font-size:10px; color:#888;">
                            Lunghezza: ${data.length} caratteri
                        </div>
                    `;
                    
                    showOutput(`‚úÖ Esportazione ${format} completata`, 'success');
                } else {
                    showOutput(`‚ùå Errore: ${data.error}`, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }
        
        function copyExportedData() {
            const textarea = document.getElementById('exportedData');
            if (!textarea || !textarea.value) {
                showOutput('‚ùå Nessun dato da copiare', 'error');
                return;
            }
            
            let textToCopy = textarea.value.trim();
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                showOutput(`‚úÖ ${lastExportedData.format.toUpperCase()} copiato!`, 'success');
            }).catch(err => {
                textarea.select();
                document.execCommand('copy');
                showOutput(`‚úÖ ${lastExportedData.format.toUpperCase()} copiato!`, 'success');
            });
        }
        
        function calculateAspectHash() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const aspect = document.getElementById('aspectInput').value.trim();
            if (!aspect) {
                showOutput('‚ùå Inserisci un aspect!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -H "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -H "${aspect}"`;
            }
            
            executeCommand();
        }

        let currentVerification = {
            originalHash: null,
            rnsHash: null,
            type: null,
            aspects: {},
            isPublic: true
        };

        // CORREZIONE: Funzione per pulire hash che inizia/finisce con <>
        function cleanHashFromAngleBrackets(hashInput) {
            if (!hashInput) return '';
            
            // Rimuovi SOLO i < > all'inizio e alla fine, non quelli all'interno
            let cleaned = hashInput.trim();
            
            // Se inizia con < e finisce con >, rimuovi entrambi
            if (cleaned.startsWith('<') && cleaned.endsWith('>')) {
                cleaned = cleaned.substring(1, cleaned.length - 1);
            }
            // Altrimenti, rimuovi solo quelli all'inizio/fine
            else {
                cleaned = cleaned.replace(/^</, '').replace(/>$/, '');
            }
            
            // Rimuovi spazi bianchi residui
            cleaned = cleaned.trim();
            
            return cleaned.toLowerCase();
        }

        async function calculateAllAspects(rnsHash) {
            const aspects = [
                'rnstransport.probe',
                'lxmf.delivery', 
                'nomadnetwork.node',
                'lxmf.propagation',
                'call.audio',
                'lxst.telephony'
            ];
            
            let html = `<div style="margin-top: 15px;"><strong>ASPECTS HASH CALCOLATI:</strong></div>`;
            html += `<div style="margin-top: 5px; font-size: 10px; font-family: monospace;">`;
            
            for (const aspect of aspects) {
                try {
                    const aspectResult = await fetch('/api/rnid', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            command: `rnid -R -i "${rnsHash}" -H "${aspect}"` 
                        })
                    });
                    
                    const aspectData = await aspectResult.json();
                    
                    if (aspectData.success && aspectData.output) {
                        let aspectHash = null;
                        const pattern = `The ${aspect} destination for this Identity is <`;
                        
                        for (const line of aspectData.output.split('\n')) {
                            if (line.includes(pattern)) {
                                const start = line.indexOf('<') + 1;
                                const end = line.indexOf('>', start);
                                if (start > 0 && end > start) {
                                    aspectHash = line.substring(start, end);
                                    break;
                                }
                            }
                        }
                        
                        if (aspectHash) {
                            currentVerification.aspects[aspect] = aspectHash;
                            html += `<div style="margin-top: 3px;">`;
                            html += `<span style="color:#888">${aspect}:</span> `;
                            html += `<code style="color:#0ff">${aspectHash}</code>`;
                            
                            if (aspectHash === currentVerification.originalHash) {
                                html += ` <span style="color:#ff0; font-size:9px;">‚Üê ORIGINALE</span>`;
                            }
                            
                            html += `</div>`;
                        }
                    }
                } catch (error) {
                    html += `<div style="color:#f00; margin-top: 3px;">${aspect}: Errore nel calcolo</div>`;
                }
            }
            
            html += `</div>`;
            return html;
        }

        // CORREZIONE: Funzione verifyHash migliorata
        async function verifyHash() {
            const hashInput = document.getElementById('verifyHashInput').value.trim();
            
            if (!hashInput) {
                showOutput('‚ùå Inserisci un hash da verificare!', 'error');
                return;
            }
            
            // CORREZIONE APPLICATA: Usa la funzione corretta per pulire <>
            const cleanHash = cleanHashFromAngleBrackets(hashInput);
            
            // Rimuovi anche eventuali spazi rimasti
            const finalHash = cleanHash.replace(/\s+/g, '');
            
            if (!finalHash) {
                showOutput('‚ùå Hash non valido dopo la pulizia!', 'error');
                return;
            }
            
            // Validazione corretta: 32 o 64 caratteri esadecimali
            if (!/^[0-9a-f]{32}$|^[0-9a-f]{64}$/.test(finalHash)) {
                showOutput(`‚ùå Hash deve essere 32 o 64 caratteri esadecimali. Ricevuti: ${finalHash.length} (${finalHash})`, 'error');
                return;
            }
            
            showOutput(`üîç Analisi hash: ${finalHash}`, 'warning');
            
            try {
                const verifyResult = document.getElementById('verifyResult');
                verifyResult.innerHTML = '<div class="warning">Analisi in corso...</div>';
                
                currentVerification = {
                    originalHash: finalHash,
                    rnsHash: null,
                    type: null,
                    aspects: {},
                    isPublic: true
                };
                
                // NOTA: rnid -R -i accetta sia hash 32 che 64 caratteri
                const aspectCheck = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: `rnid -R -i "${finalHash}"` })
                });
                
                const aspectData = await aspectCheck.json();
                
                let resultHTML = '';
                
                if (aspectData.success) {
                    const output = aspectData.output;
                    
                    if (output.includes('Recalled Identity <') && output.includes('for destination <')) {
                        currentVerification.type = 'aspect';
                        
                        const rnsMatch = output.match(/Recalled Identity <([^>]+)> for destination/);
                        if (rnsMatch) {
                            currentVerification.rnsHash = rnsMatch[1];
                        }
                        
                        resultHTML += `<div class="success">‚úÖ ASPECT HASH RILEVATO (64 chars)</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += `<div><strong>Aspect hash originale (64 chars):</strong> <code style="color:#0ff">${finalHash}</code></div>`;
                        resultHTML += `<div><strong>RNS Hash corrispondente (32 chars):</strong> <code style="color:#0ff">${currentVerification.rnsHash || 'Non trovato'}</code></div>`;
                        resultHTML += `</div>`;
                        
                        if (currentVerification.rnsHash) {
                            resultHTML += await calculateAllAspects(currentVerification.rnsHash);
                        }
                        
                    } else if (output.includes('Recalled Identity <')) {
                        currentVerification.type = 'identity';
                        currentVerification.rnsHash = finalHash;
                        
                        resultHTML += `<div class="success">‚úÖ RNS HASH (IDENTIT√Ä PUBBLICA - 32 chars)</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += `<div><strong>RNS Hash (32 chars):</strong> <code style="color:#0ff">${finalHash}</code></div>`;
                        resultHTML += `<div><em>Hash riconosciuto come identit√† RNS pubblica</em></div>`;
                        resultHTML += `</div>`;
                        
                        resultHTML += await calculateAllAspects(finalHash);
                        
                    } else {
                        currentVerification.type = 'unknown';
                        resultHTML += `<div class="error">‚ùå HASH NON RICONOSCIUTO</div>`;
                        resultHTML += `<div style="margin-top: 5px;">`;
                        resultHTML += `<div>L'hash <code>${finalHash}</code> (${finalHash.length} chars) non √® stato riconosciuto come:</div>`;
                        resultHTML += `<ul style="margin-left: 20px; margin-top: 5px;">`;
                        resultHTML += `<li>Aspect hash (64 caratteri hex)</li>`;
                        resultHTML += `<li>RNS hash (32 caratteri hex)</li>`;
                        resultHTML += `</ul>`;
                        resultHTML += `</div>`;
                    }
                } else {
                    resultHTML += `<div class="error">‚ùå ERRORE NELLA VERIFICA</div>`;
                    resultHTML += `<div style="margin-top: 5px;">${aspectData.error || 'Errore sconosciuto'}</div>`;
                    currentVerification.type = 'error';
                }
                
                const addBtn = document.getElementById('addToIdentitiesBtn');
                if (currentVerification.rnsHash && (currentVerification.type === 'aspect' || currentVerification.type === 'identity')) {
                    addBtn.style.display = 'block';
                } else {
                    addBtn.style.display = 'none';
                }
                
                verifyResult.innerHTML = resultHTML;
                showOutput(`‚úÖ Analisi completata per: ${finalHash}`, 'success');
                
            } catch (error) {
                console.error('Errore in verifyHash:', error);
                showOutput(`‚ùå Errore durante la verifica: ${error.message}`, 'error');
                document.getElementById('verifyResult').innerHTML = `<div class="error">Errore: ${error.message}</div>`;
            }
        }

        async function addToPublicIdentities() {
            if (!currentVerification.rnsHash) {
                showOutput('‚ùå Nessun RNS hash disponibile da aggiungere', 'error');
                return;
            }
            
            try {
                const nameInput = document.getElementById('publicIdentityName').value.trim();
                const defaultName = `public_${currentVerification.rnsHash.substring(0, 8)}`;
                const finalName = nameInput || defaultName;
                
                const publicIdentities = JSON.parse(localStorage.getItem('rns_public_identities') || '[]');
                
                const exists = publicIdentities.some(id => id.rns_hash === currentVerification.rnsHash);
                
                if (!exists) {
                    const publicIdentity = {
                        name: finalName,
                        rns_hash: currentVerification.rnsHash,
                        aspect_hashes: currentVerification.aspects,
                        type: currentVerification.type,
                        original_hash: currentVerification.originalHash,
                        added_date: new Date().toISOString(),
                        isPublic: true
                    };
                    
                    publicIdentities.push(publicIdentity);
                    localStorage.setItem('rns_public_identities', JSON.stringify(publicIdentities));
                    
                    showOutput(`‚úÖ Identit√† pubblica "${finalName}" aggiunta!`, 'success');
                    
                    document.getElementById('publicIdentityName').value = '';
                    loadIdentities();
                    document.getElementById('addToIdentitiesBtn').style.display = 'none';
                    
                } else {
                    const existing = publicIdentities.find(id => id.rns_hash === currentVerification.rnsHash);
                    showOutput(`‚ö† Identit√† pubblica gi√† presente come "${existing.name}"`, 'warning');
                }
                
            } catch (error) {
                showOutput(`‚ùå Errore nell'aggiunta: ${error}`, 'error');
            }
        }

        function clearVerify() {
            document.getElementById('verifyHashInput').value = '';
            document.getElementById('publicIdentityName').value = '';
            document.getElementById('verifyResult').innerHTML = '';
            document.getElementById('addToIdentitiesBtn').style.display = 'none';
            currentVerification = {
                originalHash: null,
                rnsHash: null,
                type: null,
                aspects: {},
                isPublic: true
            };
        }

        async function scanAllStorage() {
            showOutput('üîç Scansione storage...', 'warning');
            await loadIdentities();
            showOutput('‚úÖ Scansione completata', 'success');
        }
        
        function selectIdentity(path, element) {
            document.querySelectorAll('.identity-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            element.classList.add('selected');
            selectedIdentity = path;
            
            const hasSpaces = path.includes(' ');
            const cmdPath = hasSpaces ? `"${path}"` : path;
            document.getElementById('commandInput').value = `rnid -i ${cmdPath} --print-identity -P`;
            
            showOutput(`‚úÖ Selezionata: ${path.split('/').pop()}`, 'success');
        }
        
        // File import
        async function handleFileImport() {
            const fileInput = document.getElementById('fileImport');
            const file = fileInput.files[0];
            const status = document.getElementById('fileImportStatus');
            const nameInput = document.getElementById('importFileName');
            
            if (!file) {
                showOutput('‚ùå Seleziona prima un file!', 'error');
                return;
            }
            
            let suggestedName = nameInput.value.trim();
            if (!suggestedName) {
                const timestamp = new Date().getTime().toString().slice(-6);
                suggestedName = `imported_${timestamp}`;
            }
            
            status.innerHTML = `Importazione...`;
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('suggested_name', suggestedName);
            
            try {
                const response = await fetch('/api/identities/import/file', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const importedName = data.name || suggestedName;
                    const rnsHash = data.rns_hash || 'N/D';
                    const shortHash = rnsHash.substring(0, 8);
                    
                    status.innerHTML = `<span class="success">‚úÖ Importato come "${importedName}"</span>`;
                    
                    fileInput.value = '';
                    nameInput.value = '';
                    
                    showOutput(`‚úÖ Identit√† importata!\nNome: ${importedName}\nRNS: ${shortHash}...`, 'success');
                    loadIdentities();
                } else {
                    status.innerHTML = `<span class="error">‚ùå ${data.error}</span>`;
                    showOutput(`‚ùå Errore: ${data.error}`, 'error');
                }
            } catch (error) {
                status.innerHTML = `<span class="error">‚ùå ${error}</span>`;
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }

        // Data import
        async function importFromData(format) {
            const data = document.getElementById('importData').value.trim();
            const nameInput = document.getElementById('importDataName');
            
            if (!data) {
                showOutput('‚ùå Incolla i dati identit√† prima!', 'error');
                return;
            }
            
            let suggestedName = nameInput.value.trim();
            if (!suggestedName) {
                const timestamp = new Date().getTime().toString().slice(-6);
                suggestedName = `imported_${timestamp}`;
            }
            
            showOutput(`Importazione ${format}...`, 'warning');
            
            try {
                const response = await fetch('/api/identities/import/data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        data: data, 
                        format: format,
                        suggested_name: suggestedName
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    const importedName = result.name || suggestedName;
                    const rnsHash = result.rns_hash || 'N/D';
                    const shortHash = rnsHash.substring(0, 8);
                    
                    document.getElementById('importData').value = '';
                    nameInput.value = '';
                    
                    showOutput(`‚úÖ Importato\nNome: ${importedName}\nRNS: ${shortHash}...`, 'success');
                    loadIdentities();
                } else {
                    showOutput(`‚ùå Errore: ${result.error}`, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }
                
        async function generateNewIdentity() {
            const name = document.getElementById('newIdentityName').value.trim() || 'New_identity';
            
            showOutput(`Generazione "${name}"...`, 'warning');
            
            try {
                const response = await fetch('/api/identities/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(`‚úÖ Generata: ${data.path}\n${data.info}`, 'success');
                    loadIdentities();
                } else {
                    showOutput(`‚ùå Errore: ${data.error}`, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }
        
        async function executeCommand() {
            const command = document.getElementById('commandInput').value.trim();
            if (!command) {
                showOutput('Inserisci un comando!', 'error');
                return;
            }
            
            showOutput(`Esecuzione: ${command}`, 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(`‚úÖ Completato\n\n${data.output}`, 'success');
                } else {
                    let errorMsg = `‚ùå Errore (code: ${data.return_code})\n`;
                    if (data.error) errorMsg += `${data.error}\n`;
                    if (data.output) errorMsg += `${data.output}`;
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error}`, 'error');
            }
        }
        
        function showIdentityInfo() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" --print-identity`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} --print-identity -P`;
            }
            
            executeCommand();
        }

        async function uploadFileToTemp(file, purpose = 'crypto') {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('purpose', purpose);
            
            try {
                const response = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                console.log('Upload response:', data);
                
                if (data.success) {
                    return {
                        temp_path: data.temp_path,
                        output_dir: data.output_dir,
                        original_name: data.original_name
                    };
                } else {
                    throw new Error(data.error || 'Upload failed');
                }
            } catch (error) {
                console.error('Upload error:', error);
                throw new Error(`Upload error: ${error.message}`);
            }
        }

        async function cleanupTempFile(tempPath) {
            try {
                await fetch('/api/cleanup/temp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ temp_path: tempPath })
                });
            } catch (error) {
                console.warn('Cleanup failed:', error);
            }
        }
        
        function announceWithCustomAspect() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const aspect = document.getElementById('announceAspect').value.trim();
            if (!aspect) {
                showOutput('‚ùå Inserisci un aspect!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -a "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -a "${aspect}"`;
            }
            
            executeCommand();
        }
        
        function announceWithAspect() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const aspect = document.getElementById('announceAspect').value.trim() || "rnstransport.probe";
            
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                document.getElementById('commandInput').value = `rnid -R -i "${rnsHash}" -a "${aspect}"`;
            } else {
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                document.getElementById('commandInput').value = `rnid -i ${cmdPath} -a "${aspect}"`;
            }
            
            executeCommand();
        }
        
        // CORREZIONE DEFINITIVA: Funzione per gestire selezione file crittografia
        function handleCryptoFileSelect() {
            const fileInput = document.getElementById('cryptoFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('cryptoFileStatus');
            
            if (!file) return;
            
            selectedCryptoFile = file;
            status.innerHTML = `<span class="success">‚úÖ File selezionato: ${file.name} (${file.size} bytes)</span>`;
            
            const fileName = file.name;
            
            // CORREZIONE DEFINITIVA: Logica corretta per nomi file
            if (fileName.endsWith('.enc')) {
                // Se il file √® cifrato (.enc), propone nome decifrato SENZA .enc
                // Esempio: "salutiDonbass.jpg.enc" ‚Üí "salutiDonbass.jpg"
                const baseName = fileName.substring(0, fileName.length - 4); // Rimuovi ".enc"
                document.getElementById('outputFileName').value = baseName;
            } else {
                // Se il file √® normale, propone nome cifrato CON .enc
                // Esempio: "documento.txt" ‚Üí "documento.txt.enc"
                document.getElementById('outputFileName').value = fileName + '.enc';
            }
        }

        async function encryptFile() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (!selectedCryptoFile) {
                showOutput('‚ùå Seleziona prima un file!', 'error');
                return;
            }
            
            let outputFile = document.getElementById('outputFileName').value.trim();
            if (!outputFile) {
                showOutput('‚ùå Inserisci un nome per il file output!', 'error');
                return;
            }
            
            const fileName = selectedCryptoFile.name;
            if (!fileName.endsWith('.enc') && !outputFile.endsWith('.enc')) {
                outputFile = outputFile + '.enc';
                document.getElementById('outputFileName').value = outputFile;
            }
            
            showOutput(`üîí Upload e cifratura file "${selectedCryptoFile.name}"...`, 'warning');
            
            try {
                // Per cifrare serve identit√† PUBBLICA del destinatario
                let command = '';
                const uploadData = await uploadFileToTemp(selectedCryptoFile, 'encrypt');
                
                if (!uploadData.success || !uploadData.temp_path) {
                    throw new Error(uploadData.error || 'Upload failed');
                }
                
                const tempPath = uploadData.temp_path;
                const outputDir = uploadData.output_dir;
                const outputPath = outputDir + '/' + outputFile;
                
                if (selectedIdentity.startsWith('public:')) {
                    // Identit√† pubblica gi√† selezionata
                    const rnsHash = selectedIdentity.replace('public:', '');
                    command = `rnid -R -i "${rnsHash}" -e "${tempPath}" -w "${outputPath}" -f`;
                } else {
                    // Identit√† privata selezionata - dobbiamo estrarre il suo hash RNS pubblico
                    showOutput(`üîç Estrazione hash RNS pubblico dall'identit√† privata...`, 'warning');
                    
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    
                    const hashResponse = await fetch('/api/rnid', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            command: `rnid -i ${cmdPath} --print-identity` 
                        })
                    });
                    
                    const hashData = await hashResponse.json();
                    let rnsHash = null;
                    
                    if (hashData.success && hashData.output) {
                        const match = hashData.output.match(/Loaded Identity <([0-9a-f]+)>/);
                        if (match) {
                            rnsHash = match[1];
                            showOutput(`‚úÖ Hash RNS pubblico: ${rnsHash}`, 'success');
                        }
                    }
                    
                    if (rnsHash) {
                        command = `rnid -R -i "${rnsHash}" -e "${tempPath}" -w "${outputPath}" -f`;
                    } else {
                        throw new Error('Impossibile ottenere hash RNS pubblico dall\'identit√†');
                    }
                }
                
                document.getElementById('commandInput').value = command;
                
                showOutput(`‚úÖ Comando pronto:\n${command}\n\nFile verr√† salvato in: ${outputPath}`, 'success');
                
                executeCommand();
                
                setTimeout(() => {
                    cleanupTempFile(tempPath);
                }, 10000);
                
            } catch (error) {
                console.error('Error in encryptFile:', error);
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        async function decryptFile() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (!selectedCryptoFile) {
                showOutput('‚ùå Seleziona prima un file!', 'error');
                return;
            }
            
            let outputFile = document.getElementById('outputFileName').value.trim();
            if (!outputFile) {
                showOutput('‚ùå Inserisci un nome per il file output!', 'error');
                return;
            }
            
            const fileName = selectedCryptoFile.name;
            if (fileName.endsWith('.enc') && outputFile.endsWith('.enc')) {
                outputFile = outputFile.substring(0, outputFile.length - 4);
                document.getElementById('outputFileName').value = outputFile;
            }
            
            showOutput(`üîì Upload e decifratura file "${selectedCryptoFile.name}"...`, 'warning');
            
            try {
                // Per decifrare serve identit√† PRIVATA
                if (selectedIdentity.startsWith('public:')) {
                    showOutput('‚ùå Per DECIFRARE serve un\'identit√† PRIVATA (con chiave privata)', 'error');
                    return;
                }
                
                const uploadData = await uploadFileToTemp(selectedCryptoFile, 'decrypt');
                const tempPath = uploadData.temp_path;
                const outputDir = uploadData.output_dir;
                
                const outputPath = outputDir + '/' + outputFile;
                
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                
                const command = `rnid -i ${cmdPath} -d "${tempPath}" -w "${outputPath}" -f`;
                document.getElementById('commandInput').value = command;
                
                showOutput(`‚úÖ Comando pronto:\n${command}\n\nFile verr√† salvato in: ${outputPath}`, 'success');
                
                executeCommand();
                
                setTimeout(() => {
                    cleanupTempFile(tempPath);
                }, 10000);
                
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        async function encryptText() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const text = document.getElementById('cryptoTextInput').value.trim();
            if (!text) {
                showOutput('‚ùå Inserisci del testo da cifrare!', 'error');
                return;
            }
            
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const cleanCommand = 'rm -f /tmp/web_input.txt /tmp/web_encrypted.enc';
            const escapedText = text.replace(/"/g, '\\"');
            const writeCommand = `echo "${escapedText}" > /tmp/web_input.txt`;
            
            let command = '';
            
            // Per cifrare testo serve identit√† PUBBLICA
            if (selectedIdentity.startsWith('public:')) {
                const rnsHash = selectedIdentity.replace('public:', '');
                command = `${cleanCommand} && ${writeCommand} && rnid -R -i "${rnsHash}" -e /tmp/web_input.txt -w /tmp/web_encrypted.enc -f`;
            } else {
                // Identit√† privata - estrai hash pubblico
                showOutput(`üîç Estrazione hash RNS pubblico per cifratura testo...`, 'warning');
                
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                
                const hashResponse = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        command: `rnid -i ${cmdPath} --print-identity` 
                    })
                });
                
                const hashData = await hashResponse.json();
                let rnsHash = null;
                
                if (hashData.success && hashData.output) {
                    const match = hashData.output.match(/Loaded Identity <([0-9a-f]+)>/);
                    if (match) {
                        rnsHash = match[1];
                        showOutput(`‚úÖ Hash RNS pubblico: ${rnsHash}`, 'success');
                    }
                }
                
                if (rnsHash) {
                    command = `${cleanCommand} && ${writeCommand} && rnid -R -i "${rnsHash}" -e /tmp/web_input.txt -w /tmp/web_encrypted.enc -f`;
                } else {
                    showOutput('‚ùå Impossibile ottenere hash RNS pubblico', 'error');
                    return;
                }
            }
            
            const fullCommand = `${command} && base64 /tmp/web_encrypted.enc`;
            
            showOutput(`üîí Cifratura in corso...`, 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showOutput(`‚úÖ ${data.output}`, 'success');
                    
                    const outputLines = data.output.trim().split('\n');
                    let base64Lines = [];
                    let foundBase64 = false;
                    
                    for (const line of outputLines) {
                        const trimmedLine = line.trim();
                        
                        if (trimmedLine && !trimmedLine.includes(' ') && /^[A-Za-z0-9+/=]+$/.test(trimmedLine)) {
                            base64Lines.push(trimmedLine);
                            foundBase64 = true;
                        }
                        else if (foundBase64 && trimmedLine && 
                                !trimmedLine.includes('Loaded Identity') &&
                                !trimmedLine.includes('Encrypting') &&
                                !trimmedLine.includes('File') &&
                                !trimmedLine.includes('rm -f') &&
                                !trimmedLine.includes('echo') &&
                                !trimmedLine.includes('base64') &&
                                !trimmedLine.includes('rnid')) {
                            base64Lines.push(trimmedLine);
                        }
                    }
                    
                    let encryptedBase64 = base64Lines.join('');
                    
                    if (!encryptedBase64) {
                        const lines = data.output.split('\n');
                        let startCollecting = false;
                        let collectedLines = [];
                        
                        for (const line of lines) {
                            if (line.includes('base64 /tmp/web_encrypted.enc')) {
                                startCollecting = true;
                                continue;
                            }
                            
                            if (startCollecting && line.trim()) {
                                collectedLines.push(line.trim());
                            }
                        }
                        
                        encryptedBase64 = collectedLines.join('');
                    }
                    
                    if (!encryptedBase64) {
                        const lines = data.output.split('\n');
                        let lastLogLine = -1;
                        
                        for (let i = 0; i < lines.length; i++) {
                            if (lines[i].includes('File /tmp/web_input.txt encrypted')) {
                                lastLogLine = i;
                            }
                        }
                        
                        if (lastLogLine !== -1) {
                            const remainingLines = lines.slice(lastLogLine + 1);
                            encryptedBase64 = remainingLines.map(line => line.trim()).join('');
                        }
                    }
                    
                    encryptedBase64 = encryptedBase64.replace(/\s+/g, '');
                    
                    document.getElementById('cryptoEncryptedOutput').value = encryptedBase64;
                    document.getElementById('cryptoEncryptedResult').style.display = 'block';
                    
                    setTimeout(() => {
                        const outputField = document.getElementById('cryptoEncryptedOutput');
                        outputField.select();
                        outputField.focus();
                    }, 100);
                    
                } else {
                    let errorMsg = `‚ùå Errore (code: ${data.return_code})\n`;
                    if (data.error) errorMsg += `${data.error}\n`;
                    if (data.output) errorMsg += `${data.output}`;
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        async function decryptText() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            const text = document.getElementById('cryptoTextInput').value.trim();
            if (!text) {
                showOutput('‚ùå Inserisci dati cifrati!', 'error');
                return;
            }
            
            // Per decifrare serve identit√† PRIVATA
            if (selectedIdentity.startsWith('public:')) {
                showOutput('‚ùå Per DECIFRARE serve un\'identit√† PRIVATA (con chiave privata)', 'error');
                return;
            }
            
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const hasSpaces = selectedIdentity.includes(' ');
            const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
            
            const cleanInput = text.replace(/\s+/g, '');
            
            const fullCommand = `rm -f /tmp/web_encrypted.enc /tmp/web_decrypted.txt && ` +
                               `echo "${cleanInput}" | base64 -d > /tmp/web_encrypted.enc && ` +
                               `rnid -i ${cmdPath} -d /tmp/web_encrypted.enc -w /tmp/web_decrypted.txt -f && ` +
                               `cat /tmp/web_decrypted.txt && rm -f /tmp/web_encrypted.enc /tmp/web_decrypted.txt`;
            
            showOutput(`üîì Decifratura in corso...`, 'warning');
            
            try {
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    const output = data.output;
                    
                    showOutput(`‚úÖ ${output}`, 'success');
                    
                    const lines = output.split('\n');
                    let decryptedLines = [];
                    
                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        
                        if (trimmedLine && 
                            !trimmedLine.includes('Loaded Identity') &&
                            !trimmedLine.includes('Decrypting') &&
                            !trimmedLine.includes('File') &&
                            !trimmedLine.includes('rm -f') &&
                            !trimmedLine.includes('echo') &&
                            !trimmedLine.includes('base64') &&
                            !trimmedLine.includes('rnid -i') &&
                            !trimmedLine.includes('cat /tmp/web_decrypted.txt') &&
                            !trimmedLine.startsWith('[') &&
                            !trimmedLine.includes('/tmp/')) {
                            decryptedLines.push(trimmedLine);
                        }
                    }
                    
                    let decryptedText = decryptedLines.join('\n');
                    
                    if (!decryptedText) {
                        for (let i = lines.length - 1; i >= 0; i--) {
                            if (lines[i].trim()) {
                                decryptedText = lines[i].trim();
                                break;
                            }
                        }
                    }
                    
                    document.getElementById('cryptoDecryptedOutput').value = decryptedText;
                    document.getElementById('cryptoDecryptedResult').style.display = 'block';
                    
                    setTimeout(() => {
                        const outputField = document.getElementById('cryptoDecryptedOutput');
                        outputField.select();
                        outputField.focus();
                    }, 100);
                    
                } else {
                    let errorMsg = `‚ùå Errore (code: ${data.return_code})\n`;
                    if (data.error) errorMsg += `${data.error}\n`;
                    if (data.output) errorMsg += `${data.output}`;
                    showOutput(errorMsg, 'error');
                }
            } catch (error) {
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        // ============================================
        // FUNZIONI FIRMA & VERIFICA - VERSIONE CORRETTA
        // ============================================

        function handleSignFileSelect() {
            const fileInput = document.getElementById('signFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('signFileStatus');
            
            if (!file) return;
            
            selectedSignFile = file;
            status.innerHTML = `<span class="success">‚úÖ File selezionato: ${file.name} (${file.size} bytes)</span>`;
            
            const sigFileName = file.name + '.rsg';
            document.getElementById('signatureFileName').value = sigFileName;
        }

        function handleSigFileSelect() {
            const fileInput = document.getElementById('sigFileInput');
            const file = fileInput.files[0];
            const status = document.getElementById('sigFileStatus');
            
            if (!file) return;
            
            selectedSigFileForVerification = file;
            status.innerHTML = `<span class="success">‚úÖ File firma selezionato: ${file.name}</span>`;
        }

        async function signFile() {
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (!selectedSignFile) {
                showOutput('‚ùå Seleziona prima un file da firmare!', 'error');
                return;
            }
            
            if (selectedIdentity.startsWith('public:')) {
                showOutput('‚ùå Per firmare serve un\'identit√† PRIVATA (con chiave privata)', 'error');
                return;
            }
            
            showOutput(`‚úçÔ∏è Firma file: ${selectedSignFile.name}...`, 'warning');
            
            try {
                // Upload file originale
                const formData = new FormData();
                formData.append('file', selectedSignFile);
                formData.append('purpose', 'sign');
                
                const response = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Upload fallito: ${response.status}`);
                }
                
                const uploadData = await response.json();
                
                if (!uploadData.success || !uploadData.temp_path) {
                    throw new Error(uploadData.error || 'Upload fallito');
                }
                
                const tempPath = uploadData.temp_path;
                const downloadsDir = uploadData.output_dir; // ~/.rns_manager/Downloads
                const fileName = selectedSignFile.name;
                
                // Copia file originale in Downloads
                const originalInDownloads = downloadsDir + '/' + fileName;
                
                // Genera nome file firma
                const sigFileName = document.getElementById('signatureFileName').value.trim() || fileName + '.rsg';
                const sigInDownloads = downloadsDir + '/' + sigFileName;
                
                // Comando: copia originale in Downloads + firma
                const hasSpaces = selectedIdentity.includes(' ');
                const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                
                const command = `cp "${tempPath}" "${originalInDownloads}" && rnid -i ${cmdPath} -s "${originalInDownloads}" -w "${sigInDownloads}" -f`;
                
                document.getElementById('commandInput').value = command;
                
                showOutput(`‚úÖ Comando pronto:\n${command}\n\nFile originale: ${originalInDownloads}\nFirma: ${sigInDownloads}`, 'success');
                
                executeCommand();
                
                // Cleanup
                setTimeout(() => {
                    fetch('/api/cleanup/temp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ temp_path: tempPath })
                    }).catch(e => console.warn('Cleanup failed:', e));
                }, 5000);
                
            } catch (error) {
                console.error('Errore in signFile:', error);
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        async function verifySignature() {
            console.log('=== VERIFICA FIRMA - VERSIONE CORRETTA ===');
            
            if (!selectedIdentity) {
                showOutput('‚ùå Seleziona prima un\'identit√†!', 'error');
                return;
            }
            
            if (!selectedSigFileForVerification) {
                showOutput('‚ùå Seleziona prima il file firma .rsg!', 'error');
                return;
            }
            
            const fileName = selectedSigFileForVerification.name;
            console.log('File selezionato:', fileName);
            
            if (!fileName.toLowerCase().endsWith('.rsg')) {
                showOutput(`‚ùå Il file deve essere una firma (.rsg)!\nRicevuto: ${fileName}`, 'error');
                return;
            }
            
            showOutput(`üîç Verifica firma: ${fileName}...`, 'warning');
            
            try {
                // 1. Upload del file .rsg
                console.log('Upload file .rsg...');
                const formData = new FormData();
                formData.append('file', selectedSigFileForVerification);
                formData.append('purpose', 'verify');
                
                const uploadResponse = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                if (!uploadResponse.ok) {
                    throw new Error(`Upload fallito: ${uploadResponse.status}`);
                }
                
                const uploadData = await uploadResponse.json();
                console.log('Upload response:', uploadData);
                
                if (!uploadData.success || !uploadData.temp_path) {
                    throw new Error(uploadData.error || 'Upload fallito');
                }
                
                const tempPath = uploadData.temp_path;
                const downloadsDir = uploadData.output_dir; // ~/.rns_manager/Downloads
                
                console.log('Temp path:', tempPath);
                console.log('Downloads dir:', downloadsDir);
                
                // 2. Nome file finale in Downloads
                const sigFileName = selectedSigFileForVerification.name;
                const sigInDownloads = downloadsDir + '/' + sigFileName;
                const originalFileName = sigFileName.replace('.rsg', '');
                
                // 3. Comando: copia .rsg in Downloads E POI verifica
                const copyCommand = `cp "${tempPath}" "${sigInDownloads}"`;
                
                let verifyCommand;
                if (selectedIdentity.startsWith('public:')) {
                    const rnsHash = selectedIdentity.replace('public:', '');
                    verifyCommand = `rnid -R -i "${rnsHash}" -V "${sigInDownloads}"`;
                } else {
                    const hasSpaces = selectedIdentity.includes(' ');
                    const cmdPath = hasSpaces ? `"${selectedIdentity}"` : selectedIdentity;
                    verifyCommand = `rnid -i ${cmdPath} -V "${sigInDownloads}"`;
                }
                
                // 4. Comando COMPLETO: copia + verifica
                const fullCommand = `${copyCommand} && ${verifyCommand}`;
                
                console.log('Comando completo:', fullCommand);
                
                // 5. Esegui
                const response = await fetch('/api/rnid', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: fullCommand })
                });
                
                const data = await response.json();
                console.log('Risposta rnid:', data);
                
                // 6. Mostra risultato
                const verifySection = document.getElementById('verifyResultSection');
                const verifyOutput = document.getElementById('verifyResultOutput');
                
                if (verifySection && verifyOutput) {
                    verifySection.style.display = 'block';
                    
                    if (data.success) {
                        const output = data.output || '';
                        console.log('Output completo:', output);
                        
                        // Analisi SEMPLICE ma precisa
                        if (output.includes('is valid') && !output.includes('is invalid')) {
                            verifyOutput.value = `‚úÖ FIRMA VALIDA\n\n${output}`;
                            showOutput(`‚úÖ ${sigFileName}: FIRMA VALIDA`, 'success');
                        } else if (output.includes('is invalid')) {
                            verifyOutput.value = `‚ùå FIRMA NON VALIDA\n\n${output}`;
                            showOutput(`‚ùå ${sigFileName}: FIRMA NON VALIDA`, 'error');
                        } else {
                            verifyOutput.value = `‚ö† RISULTATO VERIFICA\n\n${output}`;
                            showOutput(`‚ö† ${sigFileName}: Verifica completata`, 'warning');
                        }
                    } else {
                        verifyOutput.value = `‚ùå ERRORE\n\n${data.error || data.output || 'Errore sconosciuto'}`;
                        showOutput(`‚ùå Errore: ${data.error || data.output}`, 'error');
                    }
                }
                
                // 7. Cleanup (pulisci solo il file temporaneo, non quello in Downloads)
                setTimeout(() => {
                    fetch('/api/cleanup/temp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ temp_path: tempPath })
                    }).catch(e => console.warn('Cleanup ignorato:', e));
                }, 3000);
                
                console.log('=== VERIFICA FIRMA - COMPLETATA ===');
                
            } catch (error) {
                console.error('ERRORE COMPLETO:', error);
                showOutput(`‚ùå Errore: ${error.message}`, 'error');
            }
        }

        function copyVerifyResult() {
            const output = document.getElementById('verifyResultOutput');
            if (!output || !output.value.trim()) {
                showOutput('‚ùå Nessun risultato da copiare!', 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput('‚úÖ Risultato copiato!', 'success');
            } catch (err) {
                showOutput('‚ùå Errore nella copia: ' + err, 'error');
            }
        }

        // Helper function per upload file (MANTENUTA COME NEL CODICE ORIGINALE)
        async function uploadFileToTemp(file, purpose = 'crypto') {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('purpose', purpose);
            
            try {
                const response = await fetch('/api/upload/temp', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                console.log('Upload response:', data);
                
                if (data.success) {
                    return {
                        success: true,
                        temp_path: data.temp_path,
                        output_dir: data.output_dir,
                        original_name: data.original_name
                    };
                } else {
                    return {
                        success: false,
                        error: data.error || 'Upload failed'
                    };
                }
            } catch (error) {
                console.error('Upload error:', error);
                return {
                    success: false,
                    error: `Upload error: ${error.message}`
                };
            }
        }

        // Helper function per cleanup (MANTENUTA COME NEL CODICE ORIGINALE)
        async function cleanupTempFile(tempPath) {
            try {
                await fetch('/api/cleanup/temp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ temp_path: tempPath })
                });
            } catch (error) {
                console.warn('Cleanup failed:', error);
            }
        }


        // Funzione helper per pulire pi√π file
        async function cleanupFiles(filePaths) {
            for (const filePath of filePaths) {
                if (filePath) {
                    await cleanupTempFile(filePath);
                }
            }
        }

        function copyEncryptedResult() {
            const output = document.getElementById('cryptoEncryptedOutput');
            if (!output || !output.value.trim()) {
                showOutput('‚ùå Nessun testo cifrato da copiare!', 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput('‚úÖ Testo cifrato copiato!', 'success');
            } catch (err) {
                showOutput('‚ùå Errore nella copia: ' + err, 'error');
            }
        }

        function copyDecryptedResult() {
            const output = document.getElementById('cryptoDecryptedOutput');
            if (!output || !output.value.trim()) {
                showOutput('‚ùå Nessun testo decifrato da copiare!', 'error');
                return;
            }
            
            try {
                output.select();
                output.setSelectionRange(0, 99999);
                document.execCommand('copy');
                showOutput('‚úÖ Testo decifrato copiato!', 'success');
            } catch (err) {
                showOutput('‚ùå Errore nella copia: ' + err, 'error');
            }
        }

        function clearCryptoText() {
            document.getElementById('cryptoTextInput').value = '';
            document.getElementById('cryptoEncryptedOutput').value = '';
            document.getElementById('cryptoDecryptedOutput').value = '';
            document.getElementById('cryptoEncryptedResult').style.display = 'none';
            document.getElementById('cryptoDecryptedResult').style.display = 'none';
            
            const cleanCommand = 'rm -f /tmp/web_input.txt /tmp/web_encrypted.enc /tmp/web_decrypted.txt';
            
            fetch('/api/rnid', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command: cleanCommand })
            }).catch(() => {});
            
            showOutput('üóë Testo e risultati crittografia puliti', 'warning');
        }
        
        function showOutput(message, type = '') {
            const output = document.getElementById('output');
            
            const escapedMessage = message
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            const className = type ? ` class="${type}"` : '';
            output.innerHTML = `<pre style="margin:0; padding:0; font-family:inherit; font-size:inherit; white-space:pre-wrap; word-wrap:break-word;"${className}>${escapedMessage}</pre>`;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearCommand() {
            document.getElementById('commandInput').value = '';
        }
        
        window.onload = function() {
            loadIdentities();
            document.getElementById('commandInput').value = 'rnid -h';
            setTimeout(() => executeCommand(), 500);
        };
        
        document.addEventListener('touchstart', function(event) {
            if (event.touches.length > 1) {
                event.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>